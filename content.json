{"meta":{"title":"SH'S BLOG","subtitle":"残梦学习路","description":"前端工程师,残梦,IT","author":"SH'S BLOG","url":"https://2662419405.github.io","root":"/"},"pages":[{"title":"404 Not Found","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除","path":"404.html","date":"11-18","excerpt":""},{"title":"关于我","text":"前端路上的一个小学生,喜欢钻研技术,也渴望和大佬之间的学习和交流(欢迎骚扰)关于本人各位朋友好，我是孙航(博客:残梦)，来自北方之地黑龙江，也是千万前端开发工程师中的一枚小小开发仔。相信技术改变世界。 自从加入前端大家庭后，深深热爱上它，迷人热情。 目前的技术栈如下: 前端技术栈: HTML,CSS,JavaScript,Vue全家桶,NodeJS,Angular,Hybrid,TypeScript,HTTP,网络安全,微信小程序,微信小游戏,jQuery,RN,bootstrap 后台浅析: PHP,JAVA,JAVAWeb 服务器浅析: Linux,Nginx 数据库技术栈: mysql,mongodb 深度学习: React全家桶,Webpack4.0,git,ES6 梦想 对互联网充满激情和无限力量，这就是我 热爱编程，热爱知识分享，标准 markdown 党，自律学习 Love coding , Love life (就像我的第一个域名一样,shtodream.cn) 相信一句话”技术成就一切,梦想改变未来” 长期活跃社区 github(平时做一些小的开源Demo) 博客园(日常更新自己的最新技术状态) 个人技术博客(技术成长幅度较大时更新)","path":"about/index.html","date":"11-19","excerpt":""},{"title":"所有分类","text":"","path":"categories/index.html","date":"11-28","excerpt":""},{"title":"我的友链","text":"海内存知己，天涯若比邻！相见即是缘分，欢迎各位大佬留言互换友链！ 本站不强求互换友链,只是单方面的学习,本站承诺,除特殊情况之外,友链不会挂掉 留言请告诉我你的名称、主页、头像、标签或者简介哦～ 如果想定制你的卡片颜色，也可以留言告诉我哦～（十六进制颜色码，如：#FF0000） 名称：残梦学习博客 主页：https://sunhang.top 头像：https://cdn.jsdelivr.net/gh/2662419405/CDN@1.0/sh.jpg 标签：前端丶JS 简介：知识改变命运,技术成就未来","path":"friends/index.html","date":"11-20","excerpt":""},{"title":"留言板","text":"有什么问题或想说的可以在这里讲哦~","path":"message/index.html","date":"11-19","excerpt":""},{"title":"","text":"","path":"mylist/index.html","date":"11-28","excerpt":""},{"title":"所有标签","text":"","path":"tags/index.html","date":"11-28","excerpt":""}],"posts":[{"title":"史上最详细配置HTTPS","text":"给自己的博客(或者自己的服务器)配置一个免费的ssl证书,通过https访问 参考文档: https://support.huaweicloud.com/scm_faq/scm_01_0023.html 当然还是有很多的坑 让自己的服务器也加上锁吧! HTTP（超文本传输协议），是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议，所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。 HTTPS（超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。 预览三种网站的效果 普通的http网站 https的网站 https+ssl证书的网站(也就是本网站) 获得SSL证书 我选择的华为云的ssl证书 证书一般是收费的,当然现在有很多网站推出了白嫖的ssl证书,虽然没有正常的ssl证书那样有很多安全,但是可以证明网站备案等 在华为云头部搜索”免费证书” 这里我们直接购买ssl证书,价格为0,购买之后,我们会收到一个qq邮箱提醒 我们点击下方的链接,用邮箱给我们的账号密码选择登录 如果是第一次访问,需要写一下东西,配置完之后如上图 我们下载之后,按照这个文档进行配置 如果你没有遇到问题,那么你很强,就不需要继续往下看了开始踩坑 第一个遇到的坑就是 ./Nginx -s reload 重启Nginx的时候,会出现一个ssl模板没有找到的错误 解决方式123456789101112# 进入到/usr/local/nginx-1.14.2（注：是nginx的源码包的目录），执行以下命令./configure --with-http_ssl_module # 注意这里只能用make 而不要用make install，因为执行make install是覆盖安装的意思make先备份旧的nginxcp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx_bak复制新生成的文件到安装路径：cp ./objs/nginx /usr/local/nginx/sbin/./nginx -s reload #进行重启 继续采坑中配置完之后发现,有了ssl证书,但是没有那个绿色的小锁头,很奇怪了 主要是由于页面使用了非https协议的文件,比如说&lt;img src=&quot;http:xxxx&quot; /&gt;,就会产生这个原因,那么我们把页面的http全部改写为https就发现我们的网站恢复了","path":"2019/11/27/sszxxpz/","date":"11-27","excerpt":"给自己的博客(或者自己的服务器)配置一个免费的ssl证书,通过https访问 参考文档: https://support.huaweicloud.com/scm_faq/scm_01_0023.html 当然还是有很多的坑 让自己的服务器也加上锁吧!","tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://2662419405.github.io/tags/HTTPS/"},{"name":"SSL","slug":"SSL","permalink":"https://2662419405.github.io/tags/SSL/"},{"name":"网络安全","slug":"网络安全","permalink":"https://2662419405.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"CDN","slug":"CDN","permalink":"https://2662419405.github.io/tags/CDN/"},{"name":"服务器","slug":"服务器","permalink":"https://2662419405.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"域名","slug":"域名","permalink":"https://2662419405.github.io/tags/%E5%9F%9F%E5%90%8D/"}]},{"title":"ES6学习中","text":"ES6的常见语法 ES6(常用的、重点的)数组API、正则API、字符串API都不讲模板字符串 模板字符串的基本用法1var s1 = `abc` 模板字符串的优势：12var obj=&#123; name:\"\",age:5 &#125;;var s1 =\"我叫：\"+obj.name+\"，今年：\"+obj.age+\"岁。\" 解构赋值 对象的解构赋值 123456789var obj=&#123;name:\"张三\",age:18&#125;var &#123;name,age&#125;=obj; //生成2个变量，// name值来自于obj.name、// age值来自于obj.agevar &#123;name:title&#125;=obj;//生成一个变量：title，值来自于obj.name 函数参数的解构赋值 1234567891011function f1(obj)&#123; console.log(obj.age); console.log(obj.height)&#125;//等价于function f1(&#123; age,height &#125;)&#123; console.log(age); console.log(height)&#125;f1(&#123;age:5,height:180&#125;) 补充：属性的简写 123456var a = 3 ; var c = 10;var b = &#123; a,c &#125; ; //b对象有一个a属性，a属性的值，来自于a变量 ，//还有一个c属性，c属性的值来自于c变量console.log(b) 函数的扩展rest参数 使用背景：es6的 优点：arguments是伪数组，而rest参数是真数组 1234function fn(...args)&#123; console.log(args); //数组：[1,2,3,4,5]&#125;fn(1,2,3,4,5) 箭头函数 场景：用于替换匿名函数 基本用法： 12345678//匿名函数div.onclick=function()&#123; console.log(\"你好\")&#125;//箭头函数div.onclick=()=&gt;&#123; console.log(\"你好\")&#125; 有一个参数的箭头函数 1234567var fn=(a)=&gt;&#123; console.log(\"abc\");&#125;//等价于：var fn=a=&gt;&#123; console.log(\"abc\");&#125; 有2个及更多参数的箭头函数 123var f=(a,b,c)=&gt;&#123; console.log(\"abc\")&#125; 箭头函数和普通匿名函数有哪些不同？ 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 （不常用）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 generator函数现在经常用async替代 对象的扩展 Object.assign：实现拷贝继承 对象扩展运算符123var obj1=&#123; age:5,gender:\"男\" &#125;var obj2=&#123; ...obj1 &#125;var obj3=&#123; ...obj1 , age:10 &#125; Promise为什么要有promise：解决（回调地狱）的问题回调地狱：12345678910111213141516171819//跟以前的if条件地狱很像// if()&#123;// if()&#123;// if()&#123;// &#125;// &#125;// &#125;$.get(\"/getUser\",function(res)&#123; $.get(\"/getUserDetail\",function()&#123; $.get(\"/getCart\",function()&#123; $.get(\"/getBooks\",function()&#123; //... &#125;) &#125;) &#125;)&#125;)//node开发：读取文件；开个服务器、接收一个请求、请求路径、访问数据库 Promise函数基本用法1234567891011121314var promise=new Promise((resolve,reject)=&gt;&#123; //b 把需要执行的异步操作放在这里 $.get(\"/getUser\",res=&gt;&#123; //获取数据的异步操作已经执行完毕了，等待下一步的执行，通过执行resolve函数，告诉外界你可以执行下一步操作了 //c、 resolve(res) //而执行的下一步操作，其实就是写在then的回调函数中的 &#125;)&#125;)//a、promise.then(res=&gt;&#123; //d、执行后续的操作 console.log(res);&#125;) Promise函数实现多层回调123456789101112131415161718192021new Promise((resolve,reject)=&gt;&#123; $.get(\"/getUser\",res=&gt;&#123; resolve(res) &#125;)&#125;).then(res=&gt;&#123; //用户基本信息 return new Promise(resolve=&gt;&#123; $.get(\"/getUserDetail\",res=&gt;&#123; resolve(res) &#125;) &#125;)&#125;).then(res=&gt;&#123; //用户详情 return new Promise(resolve=&gt;&#123; $.get(\"/getCart\",res=&gt;&#123; resolve(res) &#125;) &#125;)&#125;).then(res=&gt;&#123; //购物车信息&#125;) Promise函数错误处理 第一种方式 12345678910111213141516new Promise((resolve,reject)=&gt;&#123; $.ajax(&#123; url:\"/getUser\", type:\"GET\", success:res=&gt;&#123; resolve(res); &#125;, error:res=&gt;&#123; reject(res) &#125; &#125;)&#125;).then(resSuccess=&gt;&#123; //成功的返回值&#125;,resError=&gt;&#123; //失败的返回值&#125;) 第二种方式 12345678910111213141516new Promise((resolve,reject)=&gt;&#123; $.ajax(&#123; url:\"/getUser\", type:\"GET\", success:res=&gt;&#123; resolve(res); &#125;, error:res=&gt;&#123; reject(res) &#125; &#125;)&#125;).then(resSuccess=&gt;&#123; //成功的返回值&#125;).catch(resError=&gt;&#123; //失败的返回值&#125;) async async其实是一个promise的语法糖 12345678910111213async function get()&#123; console.log('开始执行'); var res = await timer() console.log('执行结束：',res);&#125;function timer()&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(\"你好\"); &#125;,1000) &#125;)&#125;get(); await可以执行异步操作，但是await必须在async函数内执行 await操作可以有返回值，这个返回值表示promise操作成功的返回值 如果await里面执行的异步操作发生了reject，或者发生了错误，那么只能使用try…catch语法来进行错误处理 class定义一个类123456789class Person &#123; constructor(name) &#123; this.name=name; &#125;&#125;//相当于：function Person(name)&#123; this.name=name;&#125; 添加实例方法12345678910111213class Person &#123; constructor(name,age) &#123; this.name=name; this.age=age; &#125; //定义方法 say() &#123; console.log(\"大家好，我叫：\"+this.name+\"，今年：\"+this.age+\"岁\"); &#125; travel()&#123; console.log(\"坐着飞机去巴厘岛\"); &#125;&#125; 添加静态方法 静态成员：静态属性、静态方法 静态属性：通过类本身来访问：Person.maxAge 静态方法：通过类本身来访问的一个方法：Person.born();1234567891011class Animal &#123; constructor()&#123; &#125; //这就是一个静态方法了 static born()&#123; console.log(\"小呆萌出生了\") &#125;&#125;//访问静态方法Animal.born(); 类的继承1234567891011121314151617//父类class Person &#123; constructor(name)&#123; this.name=name; &#125;&#125;//Student类继承自Person类class Student extends Person &#123; //构造方法 constructor(name,grade)&#123; //规定：必须调用父类构造方法，如果不调用就会报错 super(name); //调用父类构造方法，从而给子类的实例添加了name属性 this.grade=grade; &#125;&#125; 123456789[1,3,5].map(function(value,index)&#123;&#125;)[1,3,5].map((value,index)=&gt;&#123;&#125;)//以前变量和字符串拼接，现在用模板字符串 es6的新语法 个人建议：不要去试想着一下子全部把之前的代码习惯变成es6的方式 而是今年学会了模板字符串，把今天项目用到的所有字符串拼接都换成模板字符串 过了几天学会了箭头函数，把当天项目里面的所有用到的匿名函数都换成箭头函数 预习作业：通过MDN学习Object.defineProperty()的用法module –&gt;放到后面的模块化课程中讲解基本用法 导出模块： 12//common.jsexport default &#123; name:\"abc\" &#125; 导入模块： 1234//b.jsimport common from \"common.js\"console.log( common.name ) //\"abc\" 模块有多个导出12345//person.jsexport const jim = &#123; country :\"France\" &#125;export const tony = &#123; color:\"gray\" &#125;//默认的导出export default &#123; name:\"abc\" &#125; 123456//index.jsimport person , &#123; jim , tony &#125; from \"person.js\"//person：&#123; name:\"abc\" &#125;//jim：&#123; country :\"France\" &#125;//tony：&#123; color:\"gray\" &#125; 模块导入导出取别名123456789//person.jsexport const tony = &#123; color:\"gray\" &#125;export &#123; tony as Tony &#125;//index.jsimport &#123; Tony &#125; from \"person.js\"import &#123; Tony as man&#125; from \"person.js\"console.log(man) //&#123; color:\"gray\" &#125;","path":"2019/11/26/es6study/","date":"11-26","excerpt":"ES6的常见语法","tags":[{"name":"学习之旅","slug":"学习之旅","permalink":"https://2662419405.github.io/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"name":"箭头函数","slug":"箭头函数","permalink":"https://2662419405.github.io/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"},{"name":"ES6","slug":"ES6","permalink":"https://2662419405.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://2662419405.github.io/tags/JavaScript/"}]},{"title":"jQuery简单学习","text":"一.jQuery的基本使用 1.0 2.0 3.0 分别支持ie8 部分支持ie8 全部不支持ie8 开发的时候最常用的是1.几版本 分为开发版本和压缩版本 带有min的是压缩版本，一般情况下使用的是开发版本 window.onload=function(){} &lt;=&gt; $(function(){}) 绑定文档加载完成的监听 分为两种使用 使用jQuery核心函数或者jQuery核心对象 核心函数$/jQuery 核心对象 执行$()返回的对象 二.jQuert的两把利器 jQuery的核心函数,直接可用 jQuery的核心对象,执行jQuery函数调用他 三.jQuery函数的使用 I.作为一般函数使用:$(param) 1). 参数为函数 : 当DOM加载完成后，执行此回调函数 2). 参数为DOM对象 : 将DOM对象封装成jQuery对象 3). 参数为选择器字符串 : 查找所有匹配的标签，并将他们分装成jQuery对象 4). 参数为html标签字符串 : (用的少)创建标签对象并分装成jQuery对象 II.作为对象使用:$.xxx() 1). $.each() : 隐使遍历数组 回调函数中第一个为key，第二个为value 2). $.trim() : 去除两端空格 III. 事件回调函数中 this指向的是 #btn DOM对象元素 四.jQuery对象的使用I. 理解 1).即执行jQuery核心函数返回的对象 2).jQuery对象内部包含的是dom元素对象的伪数组 3).jQuery对象拥有很多有用的方法和属性 II. 基本行为 1).size()/length : 包含的DOM元素 2).[index]/get(index) : 得到DOM元素对应的下标 3).each() : 遍历DOM元素 4).index() : 得到DOM元素的下标 III. 伪数组 1).伪数组是一个对象 2).伪数组必须有length属性 3).如果这个对象的length不为0，那么必须要有按照下标存储的数据 4).没有数组特别的方法 forEach() push() pop() splice()五.jQuery基本选择器1).class &quot;.b&quot;代表所有的class属性为b的元素 2).id &quot;#div&quot; 代表id元素 3).标签 &quot;div&quot; 代表标签元素 4).子集 &quot;div.box&quot; 代表class属性为btn中的div元素 5).并集 &quot;#b,#c&quot; 代表id为c和id为b的元素六.jQuery层次选择器I.查找子元素，后代元素，兄弟元素的选择器 1). &gt; 是指当前这一代的下一代，不包括下下代 2). + 是指当前元素的下一个元素，只包括一个 3). ~ 是指当前元素的后面所有兄弟姐妹元素(就是不能包括上一级的元素)七.jQuery过滤选择器I. 选择器 1). :first 正序 2). :last 倒叙 3). :not(.box) 选择不包含clss为box的元素 4). :lt(3):gt(0) 小于第三个大于第零个 5). :contains(&quot;name&quot;) 选择所有标签的innerHTML内容是name的标签 6). :hidden() 选择隐藏的标签 7). [title] 选择所有带有title属性的标签体 8). [title=hello] 选择title属性为hello的标签 II. 多个选择器不是同时执行，而是以此执行八.jQuery隔行换色1). odd:偶数 even:奇数 nth-child(2n)偶数九.jQuery表单选择器I.表单的常用选择器 1). text[disabled] :选择text文本的不可用输入框 2). checkbox:checked :选择被选中的复选框按钮 II. :等价于[] 在选择器中等价存在十.jQuery_$工具方法I.工具方法 1). $.each() : 遍历数组对象中的数据 2). $.trim() : 去除字符串两遍的空格 3). $.type(obj) : 得到数据类型 4). $.isArray(obj) : 判断是否是数组 5). $.isFunction(obj) : 判断是否是函数 6). $.parseJSON(json) : 解析json字符串转换为js对象 II. JSON 1). &apos;{&quot;name&quot;:&quot;Tom&quot; , &quot;Age&quot;:12 }&apos; 这是一个json 2). &apos;[{&quot;name&quot;:&quot;Tom&quot;,&quot;Age&quot;:12},{&quot;name&quot;:&quot;Allen&quot;,&quot;Age&quot;:24}]&apos; 这是一个json数组 3). JSON.parse(jsonString) json字符串----&gt;js对象/数组 4). JSON.stringify(jsObj/jsArr) js对象/数组----&gt;json字符串十一.jQuery多tab点击切换I. 设计思路 获取全部的DOM元素，然后通过this获取到这个index()，最后通过操作jQuery对象的下标的方式操作 II. 先获取全部的DOM元素，然后定义一个当前显示的元素的下标，先让这个元素隐藏，在显示当前点击的元素，最后更新下标（效率上更高）十二.jQuery属性I.属性 1).attr() 一个参数代表查看，两个参数代表第二个参数覆盖 但是不能操作布尔值 2).removeAttr() 移除 3).addClass() 添加class 4).html() 标签 有字符串代表-&gt;这是标签体 5).prop() 专门操作属性值为boolean的属性值十三.jQuery的CSS操作I.CSS操作 1).css() 一个参数代表查看，两个参数代表第二个参数覆盖 2).css({&apos;color&apos;:&apos;#ff0011&apos;})可以这是多个值十四.jQuery位置操作I.offset 和 position 1).offset().left 和 offset().top 两个可以获取相对于页面的位置 2).position() 和上面是一样，这个获取的是父元素的位置十五.jQuery中的位置滚动I.常用方法 1).scrollTop() 可以得到元素的滚动高度 2).scrollLeft() 可以得到x轴滚动距离 3).上面的两个方法(number) 既可设置滚动的距离 II.如何获取窗体滚动 获取页面的html+body两个滚动条的滚动总量十六.练习 jQuery回滚到顶部I.瞬间回到顶部 $(&apos;html,body&apos;).scrollTop(0) II.平滑滚动 计算总时间，时间间隔（定时器的时间）总距离 每次移动的距离（总距离除以需要的时间） 然后用定时器执行十七.jQuery元素的尺寸I.内容尺寸 1).height() :height 2).width() :width II.内部尺寸 1).innerHeight() :height+padding 2).innerWidth() :width+padding III.外部尺寸 1).outerHeight(false/true) :height+padding+border 如果是true，加上margin 1).outerWidth(false/true) :width+padding+border 如果是true，加上margin十八.jQuery的筛选I.过滤 1).first() 第一个 2).last() 最后一个 3).eq()* 指定某一个 参数为number 4).filter(&apos;[title=hello]&apos;) 指定title属性为hello的 5).not(&apos;[title=hello]&apos;) 指定不是hello的(还包括没有title属性) 6).filter(&apos;[title][title!=hello]&apos;) 交集选择器代表两个条件 7).has(&apos;span&apos;) 指向内部标签 II.查找 1).children() 子标签 2).find() 后代标签 3).parent() 父标签 4).prevAll() 前面的标签 5).siblings() 兄弟标签十九.jQuery文档操作 *I.增删改 1).append(ELement) 向内部最后添加元素 2).prepend(Element) 向内部最前添加元素 3).before(Element) 向兄弟前面添加元素 4).after(ELement) 向兄弟后面添加元素 5).replaceWith(Element) 替换指定的内部元素 6).remove(DOM_Element) 移除指定的内部元素二十.jQuery事件处理I.常用事件 1).mouseenter() 鼠标移入 2).mouseleave() 鼠标移出 II.事件处理 1).on(eve,fn) 第一个参数代表事件的处理方式 2).off() 和第一个相对应，取消时间绑定 3).点击时传入ev -&gt;ev.clientX 到客户端左上角的距离 -&gt;ev.pageX 到页面顶部左上角的距离 -&gt;ev.offsetX 到相对于事件左上角的距离 -&gt;ev.stopPropagation() 阻止事件的冒泡 -&gt;ev.preventDefault() 阻止事件的默认行为 III.事件切换 1).hover(fn,fn) 是mouseenter,mouseleave两个函数的回调函数 IV.区别mouseover与mouseenter *mouseover:在移入子元素时也会触发,对应mouseout *mouseenter:只在移入当前元素时触发,对应mouseleave V.事件委托 1).将多个子元素(li)的事件监听委托给父元素(ul)处理 2).监听回调是加在了父元素上 3).当操作任何一个子元素(li)时，事件会冒泡到父元素(ul)上 4).父辈元素不会直接处理，而是根据event.target得到发生事件的子元素(li)，通过这个子元素调用事件回调函数 5).委托方 ： 业主 li 6).被委托方 : 中介 ul 7).添加新的子元素，自动由事件响应处理 8).减少事件监听的数量: n==&gt;1 9).设置事件委托API: $(parentSelector).delegate(childrenSelector,eventName,callback) 10).取消事件的委托API:$(parentSelector).undelegate(eventName)二十一.jQuery动画I.内置动画 1).fadeOut() 淡入 param---&gt;number 代表存在秒数 2).fadeIn() 淡出 参数和上面一样 3).fadeToggle() 淡入淡出切换 可以传一个回调函数，当切换结束的时候触发 4).不断改变元素opacity来实现 5).slideDown() 带动画的展开 6).sildeUp() 带动画的收缩 7).sildeToggle() 带动画的切换展开/收缩 8).不断改变元素height实现 9).show() 显示 10).hide() 隐藏 11).toggle() 切换 12).不断改变opacity和height和width实现 II.自定义动画 1).animate() 指定自定义动画 参数可以传一个json 分别指定值 2).animate() 不需要带有单位，还可以进行字符串的加减 3).stop() 可以阻止动画的继续进行二十二.jQuery多库共存I.当多个$库同时存在时,需要使用 II.调用jQuery.noConflict()释放$使用权 III.下文需要调用的$时，只能使用jQuery二十三.区别onload与readyI.window.onload 1).包括页面的图片加载完后才会调用(晚) 2).只能有一个监听回调 II.$(document).ready() 1).等同于$(function(){}) 2).页面加载完就回调(早) 3).可以有多个监听回调二十四.jQuery扩展工具I.$扩展本身, 使用方式----&gt;$.min() 1).定义 $.extend({ xx:function(){ ... }, yy:function(){ ... } }) II.$添加新的方法,使用方式-----&gt;$.checkAll() 1).定义 $.fn.extend({ xx:function(){ ... }, yy:function(){ ... } })","path":"2019/11/26/jqstudy/","date":"11-26","excerpt":"","tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://2662419405.github.io/tags/jQuery/"},{"name":"学习之旅","slug":"学习之旅","permalink":"https://2662419405.github.io/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"name":"前端","slug":"前端","permalink":"https://2662419405.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"npm简单使用","text":"简单概括npm常用命令 npm包管理工具 npm可以理解为前端的maven,一个包的管理工具 1. 查看npm和node版本12node -v npm -v 2. 初始化项目npm init 默认配置初始化项目 npm init -y 3. 安装本地安装npm install &lt;Module Name&gt;@版本号 全局安装npm install &lt;Module Name&gt;@版本号 -g 指定版本 ^ 插入号 + 指定版本号：比如 ^3.5.2 ，安装3.x.x的最新版本（不低于 3.5.2），但是不安装 4.x.x提升版本,不提升大版本 指定版本号：比如 3.5.2 ，只安装指定版本 ~ 波浪号 + 指定版本号：比如 ~3.5.2 ，安装 3.5.x 的最新版本（不低于 3.5.2），但是不安装 3.6.x提升版本,不提升小版本 全局安装 如果你不知道npm的全局目录在哪,可以运行下面的命令 npm root -g 修改默认全局目录 npm config set prefix &quot;D:/npm&quot; 全局安装vue模板 npm install vue -g 查看全局安装的模板 npm list -g 生产环境模块开发 生产环境依赖安装 (默认) npm install &lt;Module Name&gt;[–save|S] 开发环境模块开发 开发模块依赖安装 npm install &lt;Module Name&gt;[--save-dev|D] 批量安装npm install or npm i 4. 模板本地模板 查看所有模板 npm list 查看全局所有模板 npm list -g 查看指定模板 npm list &lt;Module Name&gt; 远程模板 查看jquery的最新版本 npm view jquery version 查看jquery的全部版本 npm view jquery versions 卸载模块 布局卸载 npm install &lt;Module Name&gt; 全局卸载 npm install -g &lt;Module Name&gt; 5.修改淘宝镜像 查看当前镜像地址 npm get registory 配置淘宝镜像 npm config set registry https://registry.npm.taobao.org 安装下载模块 npm install &lt;Module Name&gt; 还原默认镜像地址 npm config set registry https://registry.npmjs.org/","path":"2019/11/25/npmstudy/","date":"11-25","excerpt":"简单概括npm常用命令","tags":[{"name":"npm","slug":"npm","permalink":"https://2662419405.github.io/tags/npm/"},{"name":"包管理工具","slug":"包管理工具","permalink":"https://2662419405.github.io/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"}]},{"title":"博客园样式","text":"测试网址: https://www.cnblogs.com/sunhang32/ 实现目标: 学习更多的知识,了解更广的世界 简述原理: 自己整合并且简单修改 目前: 长期活跃的论坛之一,还在不断完善中 欢迎来到残梦博客园首先声明一点: 样式并不全是本人所写,是我个人整合(感觉每个人的博客都喜欢一点,所以自己整合了一下) 由于每次更新博客,都需要重新更新此文档很麻烦,所以此博客只会定期更新,如果想要使用最新版本博客园样式,请前往本人github 如果喜欢的小伙伴可以自己配置首先你要有一个博客园(这个我估计我说的有点废话了)在博客园的官网左上角开通博客园博客园的个人配置页面-&gt;先申请js权限 禁用页面的css样式 选择页面的主题 粘贴一下代码到定制页面css代码中,由于css文件较大,所以这里提供了超链接css 粘贴博客侧面公告代码1234567891011121314151617181920212223242526&lt;script type=\"text/javascript\"&gt; window.cnblogsConfig = &#123; GhVersions : 'v1.2.0', // 版本 blogUser : \"残梦\", // 用户名 essayCodeHighlightingType: \"highlightjs\", essayCodeHighlighting: \"a11y-dark\", homeTopImg: [ \"http://studyit.club/Study/sun/o_o_wallhaven-698904.jpg\" ], menuUserInfoBgImg: 'https://bndong.github.io/images/menu_bg.gif', menuNavList: [ // 列表数据 ['导航名称', '链接'] ['github', 'https://github.com/2662419405'], ['CSDN', 'https://blog.csdn.net/qq_43268396'], ['简书', 'https://www.jianshu.com/u/3c7ad314336f'], ['技能树', 'https://2662419405.github.io/sh.github.io/'], ], fontIconExtend: \"//at.alicdn.com/t/font_543384_ezv3l7gd9r7.css\", //字体图标扩展 webpageTitleOnblur : \"(◍´꒳`◍)你为何狠心离去 \", // 当前页失去焦点，页面title显示文字 webpageTitleOnblurTimeOut : 500, // 当前页失去焦点，页面title变化，延时时间，单位毫秒 webpageTitleFocus : \"(*´∇｀*) 帅的人回来了！\", // 当前页获取焦点，页面title显示文字，显示后延时恢复原title webpageTitleFocusTimeOut : 2000, // 当前页获取焦点，页面title变化，延时时间，单位毫秒 blogAvatar : \"http://studyit.club/Study/sh.jpg\", // 用户头像 blogStartDate : \"2019-11-07\", // 入园时间，年-月-日。入园时间查看方法,鼠标停留园龄时间上，会显示入园时间 &#125;&lt;/script&gt;&lt;script src=\"https://cdn.jsdelivr.net/gh/BNDong/Cnblogs-Theme-SimpleMemory@v1.2.0/src/script/simpleMemory.min.js\"&gt;&lt;/script&gt; 粘贴页首代码 1// 此处为空 粘贴页脚代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!-- 滚动进度 --&gt;&lt;div id=\"bottomProgressBar\"&gt;&lt;/div&gt;&lt;!-- 音乐菜单 --&gt;&lt;link rel=\"stylesheet\" href=\"https://blog-static.cnblogs.com/files/elkyo/APlayer.min.css\"&gt; &lt;div id=\"player\" class=\"aplayer aplayer-withlist aplayer-fixed\" data-id=\"3025663508\" data-server=\"netease\" data-type=\"playlist\" data-order=\"random\" data-fixed=\"true\" data-listfolded=\"true\" data-theme=\"#2D8CF0\"&gt;&lt;/div&gt; &lt;script src=\"https://blog-static.cnblogs.com/files/elkyo/APlayer.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://blog-static.cnblogs.com/files/elkyo/Meting.min.js\"&gt;&lt;/script&gt;&lt;!-- 网站运行时间 --&gt;&lt;p style=\"text-align:center;\"&gt;&lt;span id=\"timeDate\"&gt;载入天数...&lt;/span&gt;&lt;span id=\"times\"&gt;载入时分秒...&lt;/span&gt;&lt;/p&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date(\"11/06/2019 17:38:00\");//在此处修改你的建站时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = \"0\" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = \"0\" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = \"0\" + snum;&#125; document.getElementById(\"timeDate\").innerHTML = \"本站勉强运行 \"+dnum+\" 天 \"; document.getElementById(\"times\").innerHTML = hnum + \" 小时 \" + mnum + \" 分 \" + snum + \" 秒\"; &#125; setInterval(\"createtime()\",250);&lt;/script&gt;&lt;!-- 右下角菜单 --&gt;&lt;div id=\"rightMenu\"&gt;&lt;/div&gt; &lt;!--看板娘 - 猫--&gt; &lt;script src=\"https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js\"&gt;&lt;/script&gt;&lt;script&gt; L2Dwidget.init(&#123; \"model\": &#123; jsonPath: \"https://unpkg.com/live2d-widget-model-hijiki/assets/hijiki.model.json\",&lt;!--这里改模型，前面后面都要改--&gt; \"scale\": 1 &#125;, \"display\": &#123; \"position\": \"left\",&lt;!--设置看板娘的上下左右位置--&gt; \"width\": 100, \"height\": 200, \"hOffset\": 70, \"vOffset\": 0 &#125;, \"mobile\": &#123; \"show\": true, \"scale\": 0.4 &#125;, \"react\": &#123; \"opacityDefault\": 0.5,&lt;!--设置透明度--&gt; \"opacityOnHover\": 0.2 &#125; &#125;);window.onload=function()&#123; $(\"#live2dcanvas\").attr(\"style\",\"display:block;position: fixed; opacity: 0.7; left: 70px; bottom: 0px; z-index: 1; pointer-events: none;\")&#125;&lt;/script&gt;&lt;!-- 线条效果 --&gt;&lt;script type=\"text/javascript\"color=\"220,220,220\" opacity='0.9' zIndex=\"-2\" count=\"500\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"https://blog-static.cnblogs.com/files/sunhang32/myconsole.js\"&gt;&lt;/script&gt;&lt;!-- 文字显示 --&gt;&lt;script type=\"text/javascript\" src=\"https://files.cnblogs.com/files/sunhang32/myText.js\"&gt;&lt;/script&gt; ————–如果你对你的代码不满意的话,可以接下来自定义设置—————- 此处请前往github","path":"2019/11/24/bkyys/","date":"11-24","excerpt":"测试网址: https://www.cnblogs.com/sunhang32/ 实现目标: 学习更多的知识,了解更广的世界 简述原理: 自己整合并且简单修改 目前: 长期活跃的论坛之一,还在不断完善中","tags":[{"name":"博客园","slug":"博客园","permalink":"https://2662419405.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"样式自定义","slug":"样式自定义","permalink":"https://2662419405.github.io/tags/%E6%A0%B7%E5%BC%8F%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"name":"BLOG","slug":"BLOG","permalink":"https://2662419405.github.io/tags/BLOG/"},{"name":"jQuery","slug":"jQuery","permalink":"https://2662419405.github.io/tags/jQuery/"}]},{"title":"第一个接触的前端项目","text":"测试网址: http://studyit.club 实现目标: 简易版社团,学习资源分享,富文本论坛,空间,美图秀秀等 简述原理: 常见前端框架混合使用 目前: 由于精力有限,目前暂停维护和开发 Study IT .club萌新报道1Hello Everybody ​ 第一次尝试分享一个自己写的非常简单的自己社团的官网 ​ 有兴趣的小伙伴可以去开一下 ——-&gt; 网站地址 效果图 语言和框架 数据库方面使用Mysql 数据库 没有事务处理 存储引擎为MyISAM 后台语言为PHP 讨论专区的框架为BootStrap 首页框架为 jQuery 谈论专区发帖的模块使用了 富文本编辑器UEditor 在个人空间主要AJAX滚动局部刷新 个人空间方面用了QQ表情包 个人设置用了美图秀秀的PC插件crossdomain.xml 个人空间使用 Highslide.js图片预览插件和多图片上传插件 安装和使用 需要挂载在本地的PHP服务器之上 推荐使用PHPstudy或者warm等集成开发环境 数据库方面配置在connect/config.php中,端口和数据库配置在这里面 所有的数据库模型都在主目录的 数据库.txt目录下面 美图秀秀插件配置:把主目录的 crossdomain.xml放在服务器的根目录 项目源码—-&gt;地址","path":"2019/11/20/dycjcqd/","date":"11-20","excerpt":"测试网址: http://studyit.club 实现目标: 简易版社团,学习资源分享,富文本论坛,空间,美图秀秀等 简述原理: 常见前端框架混合使用 目前: 由于精力有限,目前暂停维护和开发","tags":[{"name":"我的项目","slug":"我的项目","permalink":"https://2662419405.github.io/tags/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/"},{"name":"学习之旅","slug":"学习之旅","permalink":"https://2662419405.github.io/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"}]},{"title":"我的第一个React项目","text":"测试网址: http://shtodream.cn:9093 实现目标: 双向聊天 简述原理: socketio全双工通信 目前bug: 注册之后再次登录才可以聊天 简招 (React+Node+MongoDB) 开始制作的时间是从 2019-10-10 起至今 自己也发布过几个小型的demo,虽然没人看(๑•ૅૄ•๑), 但还是喜欢与大家共同学习进步 测试网址 ———&gt; 网址 介绍校园招聘APP,是一款手机端的求职网站,招聘者可以注册为BOSS,求职者可以注册为牛人,牛人和BOSS可以聊天,并且可以互相查看到对方的基本信息和简介薪资等方面 计划制作: 使用React的Antd-mobile支持手机端端制作 ReactNative独立开发App端和IOS 有人肯定会很好奇,PC和手机为何要制作两次,主要是本人很萌新,想要学习更多的框架 只有学习更多的框架,并且锻炼更好的自学能力,才能更上一层楼 关于我我是一个热门计算机并且对计算机充满兴趣的程序员 学过Java,.net,PHP,曾经一度认为PHP是最牛逼的语言 后来正式的接触前端,学习过 ES6 Node React Vue ReactNative Angular 微信一系列开发 jq,bootstarp等一些简单库 发现前端很神奇,比后台和数据方面更加的有意思,想要称为一名前端工程师 项目简述 这是一个React项目,你的电脑要具备Node(8.0)以上 所使用的node包技术阐述 前端主要采用了React全家桶，没什么多说的，脚手架构建项目，react-router控制路由，axios进行前后端交互。后端是基于node搭的服务，用的是express。我为什么不用koa呢，纯粹是图方便，因为koa不熟（捂脸）。聊天最重要的当然是通信，项目用socket.io来进行前后端通信。 =============分割线 下面是每个包的详细解释=============== (按需加载问题) 使用babel-plugin-import包 (由于跨域问题) 在package.json中使用proxy配置 需要详细说明一下,安装完这个包,需要在package.json文件中配置 \"proxy\": \"http://localhost:9093\" &lt;!--￼0--&gt; (配置服务端渲染) 使用babel-cli包 安装 npm install babel-cli --save &lt;!--￼1--&gt; 目录结构 123456789101112131415161718192021222324252627282930313233// 项目结构├─build├─config├─data│ ├─MongoDB // 数据库解释 ├─server // 后台│ ├─model // 数据库原型 │ ├─main // 后台文件入口 │ ├─user // 后台接口api ├─src│ ├─components // 全局组件│ │ ├─autoRouter│ │ ├─avatar-select│ │ ├─boss│ │ ├─chat│ │ ├─Dashboard│ │ ├─genius│ │ ├─img│ │ ├─logo│ │ ├─msg│ │ ├─navlink│ │ ├─shForm│ │ ├─user│ │ └─chatCard│ ├─router // 路由│ ├─index // 入口 │ ├─util // 方法│ ├─config // 请求拦截│ └─container│ ├─bossinfo // boss│ ├─login // 登录│ ├─register // 注册│ └─genuisinfo // 牛人 注册时, 进行密码MD5加密 12345// md5加密function md5pwd(pwd)&#123; const salt = 'qwe123~~-!@#$%^&amp;&amp;*()sunhang' return utility.md5(utility.md5(salt+pwd))&#125; 进行登录以及cookie的存储 123456789101112131415161718//进行注册Router.post('/register',(req,res)=&gt;&#123; const &#123; user,pwd,type &#125; = req.body User.findOne(&#123;user&#125;,(err,doc)=&gt;&#123; if(doc)&#123; return res.json(&#123;code:1,msg:'用户名存在'&#125;) &#125; const userModel = new User(&#123;user,type,pwd:md5pwd(pwd)&#125;) userModel.save(function(e,d)&#123; if(err)&#123; return res.json(&#123;code:2,msg:'后端出错了'&#125;) &#125; const &#123;user,type,_id&#125; = d res.cookie('userid',_id) return res.json(&#123;code:3,msg:'注册成功',data:&#123;user,type,_id&#125;&#125;) &#125;) &#125;)&#125;) axios拦截器的制作 1234567891011121314import axios from 'axios'import &#123; Toast &#125; from 'antd-mobile'//拦截请求axios.interceptors.request.use(function(config)&#123; Toast.loading('加载中',0); return config;&#125;)//拦截响应axios.interceptors.response.use(function(config)&#123; Toast.hide(); return config;&#125;) 登录和注册效果展示 双方聊天展示 消息的更新和排序 手机端表情包展示 手机端的表情包就是可以用的,现在的表情包都可以直接使用了,不同代码了,很神奇 后台方向 由于本人主要是面向前端,数据库就是MongoDB 数据库的使用请参照data目录下面的mongodb.md 数据库方面使用 (mongoose) 后台主要使用node的express 后台文件在server 使用方式 需要电脑有 mongo 和 react 还有node环境 首先:下载本项目 // 第一种方式 npm install //安装包依赖 npm run build //打包项目 npm run server //启动 打开浏览器输入localhost:9093 &lt;!--￼6--&gt; 如果还有bug和建议,欢迎告诉我 (͏ ˉ ꈊ ˉ)✧˖° 一开始还是遇到了很多的坑,第一次使用antd-mobile这个库,最主要的坑,还是对于项目的上线运行,毕竟个人不太擅长服务器的使用,在配置Nginx的时候卡了很久,为了性能优化,SSR渲染也是花了很大的心血,感觉里面的坑太多了,总的来说收获还是很大的,后期我还会画时间进行界面上的美化 感觉支持 喜欢的朋友记得给个star","path":"2019/11/18/dygReactxm/","date":"11-18","excerpt":"测试网址: http://shtodream.cn:9093 实现目标: 双向聊天 简述原理: socketio全双工通信 目前bug: 注册之后再次登录才可以聊天","tags":[{"name":"我的项目","slug":"我的项目","permalink":"https://2662419405.github.io/tags/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/"},{"name":"学习之旅","slug":"学习之旅","permalink":"https://2662419405.github.io/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"name":"React","slug":"React","permalink":"https://2662419405.github.io/tags/React/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://2662419405.github.io/tags/MongoDB/"},{"name":"Node","slug":"Node","permalink":"https://2662419405.github.io/tags/Node/"}]}]}