{"meta":{"title":"SH'S BLOG","subtitle":"残梦学习路","description":"前端工程师,残梦,IT","author":"SH'S BLOG","url":"https://2662419405.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-11-18T01:42:42.000Z","updated":"2019-11-24T05:42:20.598Z","comments":true,"path":"404.html","permalink":"https://2662419405.github.io/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于我","date":"2019-11-19T02:43:46.000Z","updated":"2020-06-29T05:35:02.808Z","comments":true,"path":"about/index.html","permalink":"https://2662419405.github.io/about/index.html","excerpt":"","text":"前端路上的一个小学生,喜欢钻研技术,也渴望和大佬之间的学习和交流(欢迎骚扰)关于本人各位朋友好，我是孙航(博客:残梦)，来自北方之地黑龙江，一个苦逼的程序员，也是千万前端开发工程师中的一枚小小开发仔。相信技术改变世界。 自从加入前端大家庭后，深深热爱上它，迷人热情。 一枚 90 后，跨越了 20 世纪，爱新奇，爱折腾。 苦逼的在校大学生(/ω＼) 现主要学习前端 Web,全栈开发 目前的技术栈如下: 前端技术栈: HTML,CSS,JavaScript,Vue全家桶,NodeJS,Angular,Hybrid,TypeScript,HTTP,网络安全,微信小程序,微信小游戏,jQuery,RN,bootstrap 后台浅析: PHP,JAVA,JAVAWeb 服务器浅析: Linux,Nginx 数据库技术栈: mysql,mongodb 深度学习: React全家桶,Webpack4.0,git,ES6 域名说实在的，买过不少的服务器和域名，一开始还由于单词拼错了(study-&gt;stusy)，解析不上，太苦逼了 想购买 shblog.com 发现也被人买了，只好买上 sunhang.com 结果发现也被买了，我太难了 最后购买了现在这个域名 sunhang.top 当然第一个域名是 shtodream.cn 意思就是希望自己可以一天天的在进步，能学到更多的知识吧 关于本站建立这个博客的初心其实很简单，那就是记录所学所得。学得多，忘得也多吧。何尝不找一个地方去记录那些点点滴滴呢？养成记录的习惯，其实没有什么坏处呢。同时，如果当陌生人的你看到我的某篇文章对你有所感触，那一定很温暖吧。 搭建过程Hexo静态博客框架，由Github,Gitee,Coding三方面托管，使用&lt;Material-X主题，经过轻度魔改而成。 梦想 对互联网充满激情和无限力量，这就是我 热爱编程，热爱知识分享，标准 markdown 党，自律学习 Love coding , Love life 相信一句话”技术成就一切,梦想改变未来” 成长经历 时间 事件 学到的知识 2014 年 10 月 加入了 IT 社团,和老学长学习 html,css,js 2015 年 1 月 初入算法 c,c++ 2015 年 9 月份 被迫当了 IT 社团社长(光杆司令还要讲课) 深度学习 html,css,js 2015 年 11 月份 参加挑战杯 php,mysql,jquery,layui 等 2016 年 3 月份 全国微信小程序 ES6,Node,WebSocket,小程序 2016 年 4 月份 参加程序设计大赛 背包,快速幂,动态规划,贪心 2016 年 5 月份 第一个上线网站 bootstarp,git,服务器搭建,linux,ngxin 2016 年 6 月份 开始正式学习前端 React,vue,github,webpack 2016 年 10 月份 开始更新自己的博客 Hexo,pjax,githubActions,live2d 2017 月份 了解和学习更多前端方面的特点 webhook,Travis,jest,RN,flutter 未完待续… 长期活跃社区 github(平时做一些小的开源 Demo) 博客园(日常更新自己的最新技术状态) 个人技术博客(技术成长幅度较大时更新)"},{"title":"所有分类","date":"2019-11-28T13:15:05.584Z","updated":"2019-11-24T06:02:05.545Z","comments":true,"path":"categories/index.html","permalink":"https://2662419405.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的友链","date":"2019-11-20T00:16:04.000Z","updated":"2020-05-18T06:23:50.727Z","comments":true,"path":"friends/index.html","permalink":"https://2662419405.github.io/friends/index.html","excerpt":"","text":"海内存知己，天涯若比邻！相见即是缘分，欢迎各位大佬留言互换友链！ 本站不强求互换友链,只是单方面的学习,本站承诺,除特殊情况之外,友链不会挂掉 留言请告诉我你的名称、主页、头像、标签或者简介哦～ 如果想定制你的卡片颜色，也可以留言告诉我哦～（十六进制颜色码，如：#FF0000） 名称：残梦 主页：https://sunhang.top 头像：https://cdn.jsdelivr.net/gh/2662419405/CDN@1.0/sh.jpg 标签：前端丶JS"},{"title":"留言板","date":"2019-11-19T02:43:55.000Z","updated":"2019-12-14T03:43:38.801Z","comments":true,"path":"message/index.html","permalink":"https://2662419405.github.io/message/index.html","excerpt":"","text":"采用 Valine 评论系统，这个有邮箱回复并且有表情包，请尽情灌水吧！😉😉😉"},{"title":"","date":"2019-11-28T13:15:05.589Z","updated":"2019-11-24T06:01:44.507Z","comments":true,"path":"mylist/index.html","permalink":"https://2662419405.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-11-28T13:15:05.590Z","updated":"2019-11-24T06:00:36.744Z","comments":true,"path":"tags/index.html","permalink":"https://2662419405.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"前端项目实战大合集","slug":"xiang","date":"2020-05-18T06:26:25.703Z","updated":"2020-05-18T07:03:56.356Z","comments":true,"path":"2020/05/18/xiang/","link":"","permalink":"https://2662419405.github.io/2020/05/18/xiang/","excerpt":"名称 源码 线上网址 技术栈 美团PC端 源码 线上 原生React+antd+Koa+mongoose 美团移动端(推荐) 源码 线上 umi+dva+antd+Koa+mongoose 美团后台 源码 线上 vue+nuxt+elment+Koa+mongoose 饿了么多端开发 源码 线上 taro+taro-ui 饿了么微信小程序 源码 暂无 原生微信小程序 后台管理系统 (力荐) 源码 线上 TS + Hooks + Redux React封装自己组件 源码 线上 TS + Hooks","text":"名称 源码 线上网址 技术栈 美团PC端 源码 线上 原生React+antd+Koa+mongoose 美团移动端(推荐) 源码 线上 umi+dva+antd+Koa+mongoose 美团后台 源码 线上 vue+nuxt+elment+Koa+mongoose 饿了么多端开发 源码 线上 taro+taro-ui 饿了么微信小程序 源码 暂无 原生微信小程序 后台管理系统 (力荐) 源码 线上 TS + Hooks + Redux React封装自己组件 源码 线上 TS + Hooks 开场白哈哈哈,纯属啰嗦着玩,经过shansan大佬的提醒发现,自己确实很久没有更新博客了,最近一直在研究一些源码(纯属瞎搞),然后自己写了一个Demo,也算是对于两大框架的综合练习吧,今天就说一下我踩到过的坑 实战合集 包含上面在内的听多实战合集,每个都是跑通了几个小页面之后,就没有继续往深了去写 主要是对于技术栈的练习和踩坑的过程 除去实战,最近还写了一个Demo合集,大概包含了我2020年学到过的全部知识点 踩过的坑 由于React属于单页面应用,在页面跳转的时候,路由是不会回到顶部的,需要单独提炼一个组件 React在开发期间如果想要配置代理的话需要使用第三方包http-proxy-middleware,在package.json中配置的proxy只能配置为字符串格式 关于React的鉴权,有三种形式 第一种使用react-router配置的路由守卫onEnter在内部进行判断是否可以进入页面 第二种是使用一个独立的layout布局页面,把需要守卫的路由都设置为他的props.children这样子(antd-pro)采用的是这种形式 第三种比较推荐,使用的是配置式路由,把路由拆分为一个对象,和vue-router一样的原理,然后利用HOC的特性进行编写 关于前后端交互安全问题,使用jwt规范,把需要守卫的请求用jwt包裹起来,如果没有携带token,则返回401状态码 对于React中的redux的数据不可变,直接使用immutablejs来操作,既可以提高性能,还可以解决数据直接修改的问题 其中在React中使用到了百度地图的API,但是在React内部组件中使用的时候,就必须要用widown.BMap等格式引用 小声逼逼,vue的话没碰到,可能是做的太小了,其中就是在nuxt部署的时候出现了点问题 性能篇 配置各类按需加载,就是使用babel提供的第三方包来配置 期间内对于图片的预加载和懒加载配置,预加载是先用new Image()来读取,等计数达到数量再显示页面.懒加载就是用一个base64编码的图片先覆盖,等滚动的时候加载 修改webpack 配置webpack-bundle-analyzer来进行打包文件大小的分析 把公共文件提取,例如React,ReactDom,Vue等包,使用cdn引入,减少每个页面的引用次数 配置externals来让防止import包导入到bundle中 资源内联,把一些不影响性能的包直接内联到页面中,使用raw-loader","categories":[{"name":"TS","slug":"TS","permalink":"https://2662419405.github.io/categories/TS/"}],"tags":[{"name":"React","slug":"React","permalink":"https://2662419405.github.io/tags/React/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://2662419405.github.io/tags/MongoDB/"},{"name":"TS","slug":"TS","permalink":"https://2662419405.github.io/tags/TS/"},{"name":"Hooks","slug":"Hooks","permalink":"https://2662419405.github.io/tags/Hooks/"},{"name":"Vue","slug":"Vue","permalink":"https://2662419405.github.io/tags/Vue/"},{"name":"Umi","slug":"Umi","permalink":"https://2662419405.github.io/tags/Umi/"},{"name":"Koa","slug":"Koa","permalink":"https://2662419405.github.io/tags/Koa/"}]},{"title":"nginx特点和使用","slug":"nginx","date":"2020-01-15T12:41:23.000Z","updated":"2020-01-15T12:43:22.656Z","comments":true,"path":"2020/01/15/nginx/","link":"","permalink":"https://2662419405.github.io/2020/01/15/nginx/","excerpt":"nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；nginx可以作为一个HTTP服务器进行网站的发布处理，另外nginx可以作为反向代理进行负载均衡的实现。","text":"nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；nginx可以作为一个HTTP服务器进行网站的发布处理，另外nginx可以作为反向代理进行负载均衡的实现。 nginx服务器基础nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；nginx可以作为一个HTTP服务器进行网站的发布处理，另外nginx可以作为反向代理进行负载均衡的实现。 :tada:个人的小总结,我是一个前端的小学生,我为何还要去学习服务器,node,还要nginx等等内容呢,有几点原因吧,第一点就是最近几年前端发展非常的快,以后前端的任务量可能会越来越大,大前端或者全栈这些词都在说明一些问题,所以也就变成了前端的一些必会技能了,第二点就是我们面试的时候总是被问到是否使用过某些后台语言技术或者使用过一些后台吗,那么公司也是为了让我们在开发的过程中能够更好的和后台的人员配合与交流,所以nginx 很重要,那么本网站就是我做的一个nginx的反向代理,接下里我们详细了解一下吧 特点 反向代理 负载均衡 nginx简单实用 什么是代理?什么是正向,又为何有反向?代理关于代理 说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道； 正向代理在正常的情况下，国内的网络是访问不了google，youtobe的，但是如果我配置一个代理或者使用一个代理软件，就可以访问了。这个代理软件就是做了正向代理。就相当于是我们去商场买东西，但是商场里的东西都是代理的工厂的货，或者你也可以理解为现在流行的海外代购，那些海外代购的人就是帮我们的正向代理。 我们的科学上网,也就是翻墙就属于一种正向代理 反向代理反向代理就好像我们在淘宝购物,我们在一个非常大的连锁商家购买了食品(例如三只松鼠),然后我们就不需要去关心他们究竟怎么发货了,过几天我们的零售就收到了,其实他就是一个反向代理,我们下单的过程就像是发出了一个请求到他们的服务器上,然后他们会根据我们的地方去寻找最近的一个他们的代理商,让他们给我发货,如下 其他作用: 反向代理在我们的生活中很重要,他可以帮助我们解决跨域问题,并且是比较流行的一种解决跨域的方法,(jsonp,代理,cors三种,这里面不说其他两种),跨域产生的原因就是我们的客户端发出了请求,并且是一个不同源的请求就会造成跨域,但是服务器发出的不同源请求就不会产生跨域问题,:egg:那么想到了一种思路,如果我们让我们的请求先发送到同源的服务器,然后通过这个服务器发送给另外一个不同源的服务器不就解决了吗?那么这个地方就是用了一个反向代理,在前端进行快速开发中很有用 正向+反向通常情况下，我们在实际项目操作时，正向代理和反向代理很有可能会存在在一个应用场景中，正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向单利服务器，反向代理了多台真实的业务处理服务器。具体的拓扑图如下 总结正向代理就是我们的请求发送到服务器之前有一个拦截,他帮我们发送请求了,正向代理更靠近客户端,对server透明 反向代理就是我们的请求已经发送到服务器了,服务器帮我们转发到了不同的地方,反向代理更靠近服务器,对client透明 负载均衡为何要用到负载均衡负载均衡是大型项目优化的一个必备点,例如某宝在双十一的时候,需要同时抵抗上千万人快速下单,这个访问量是非常可怕的,那么为何某宝可以抵抗的非常好呢?他们也使用了负载均衡,把他们的服务器复制几份,然后放到了不同的端口上,那么有的人访问可能他访问的就是网站1,有的人访问的就是网站2,再配合node做一个快速IO的中间层,就可以让同时下单量可以几何式的上升都没有问题,一个小的demo如下 如何使用负载均衡 先去做两个一模一样的服务器 10001端口一个服务器 12345678const http = require('http');const server = http.createServer((request,response)=&gt;&#123; response.end('10001')&#125;)server.listen('10001',()=&gt;&#123; console.log('服务器启动在10001端口上')&#125;) 10002端口一个服务器 12345678const http = require('http');const server = http.createServer((request,response)=&gt;&#123; response.end('10002')&#125;)server.listen('10002',()=&gt;&#123; console.log('服务器启动在10002端口上')&#125;) 配置一下我们的nginx 12345678910111213141516171819202122232425worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; upstream dalaoyang-server &#123; server localhost:10001; //服务器1 server localhost:10002; //服务器2 &#125; server &#123; listen 10000; //监听我们访问的端口 server_name localhost; location / &#123; proxy_pass http://dalaoyang-server; //指向我们上面的轮询的名字 proxy_redirect default; &#125; &#125;&#125; 然后访问我们的10000端口就会发现,我们有时候会访问到10001,有时候会访问到10002 nginx简单实用nginx是一个功能非常强大的web服务器加反向代理服务器 在项目使用中，使用最多的三个核心功能是反向代理、负载均衡和静态服务器 这三个不同的功能的使用，都跟nginx的配置密切相关，nginx服务器的配置信息主要集中在nginx.conf这个配置文件中，并且所有的可配置选项大致分为以下几个部分 123456789101112131415161718192021222324252627282930313233343536main # 全局配置 events &#123; # nginx工作模式配置 &#125; http &#123; # http设置 .... server &#123; # 服务器主机配置 .... location &#123; # 路由配置 .... &#125; location path &#123; .... &#125; location otherpath &#123; .... &#125; &#125; server &#123; .... location &#123; .... &#125; &#125; upstream name &#123; # 负载均衡配置 .... &#125;&#125; 如上述配置文件所示，主要由6个部分组成： main：用于进行nginx全局信息的配置 events：用于nginx工作模式的配置 http：用于进行http协议信息的一些配置 server：用于进行服务器访问信息的配置 location：用于进行访问路由的配置 upstream：用于进行负载均衡的配置 我平时多余服务器用的比较少,详细资料可以看下面,如果有问题欢迎讨论修改 参考资料 CSDN使用大全 简书负载均衡","categories":[{"name":"nginx","slug":"nginx","permalink":"https://2662419405.github.io/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://2662419405.github.io/tags/nginx/"},{"name":"跨域","slug":"跨域","permalink":"https://2662419405.github.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://2662419405.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"name":"代理","slug":"代理","permalink":"https://2662419405.github.io/tags/%E4%BB%A3%E7%90%86/"}]},{"title":"node 常用工具大整合","slug":"nodegongju","date":"2019-12-31T06:25:37.000Z","updated":"2019-12-31T07:18:26.252Z","comments":true,"path":"2019/12/31/nodegongju/","link":"","permalink":"https://2662419405.github.io/2019/12/31/nodegongju/","excerpt":"node 常用工具大整合 pm2 解决了node不能多线 nvm 让你的电脑里安装很多个不同的node版本 nrm 快速管理你的npm,多个镜像源内切换 nodemon 监控node代码段是否更新,让代码重新运行","text":"node 常用工具大整合 pm2 解决了node不能多线 nvm 让你的电脑里安装很多个不同的node版本 nrm 快速管理你的npm,多个镜像源内切换 nodemon 监控node代码段是否更新,让代码重新运行 node 常用工具大整合 这些都是我个人平常总是使用的一些关于node的工具,不喜勿喷 pm2 先声明对于线程的补充 我们引用官方的解释：线程可以独立运行的最小的CPU单位，可以在同一个进程里并发运行，共享该进程下的内存地址空间 都说js是单线程的语言,即使有很多工具的帮助,也改变不了单线程的一个特点,即使是使用了node之后 node的最大特点是异步I/O,node官网的几乎所有方法都提供了关于异步的使用方法,比如dir.read(callback)和dir.readSync(),但是node还是被很多人排挤的一部分原因是没办法多线程去运行node项目,但是pm2的诞生可以说是又极大的提升了node的地位,他可以充分利用cpu和内存的资源,让node发挥到了极致 关于pm2的常用命令 npm install pm2 -g 全局安装pm2 pm2 start xxx 运行某一个脚本 pm2 list 查看全部运行的node程序 pm2 stop &lt;app_name|namespace|id|’all’|json_conf&gt; 停止运行 pm2 delete &lt;app_name|namespace|id|’all’|json_conf&gt; 删除 pm2 reload all 重新加载所有的node线程 pm2 logs 查看所有日志 nvm nvm是一种用来让你的电脑同时可以安装多个node版本,而且可以快速的切换各个node之间的版本,在开发的过程中,总会遇到一些要求node版本的特殊并且过分的理由,比如上次踩坑安装的easy-mock模拟的数据接口,竟然过分的要求node版本是1.8.x,太难了=-= npm i -g nvm 全局安装nvm nvm ls 查看电脑安装了几个版本的node nvm install node 安装最新版本的node nvm install 6.14.4 安装制定版本的node nvm use 6.14.4 使用某个版本的node nvm uninstall 6.14.1 卸载某个版本的node 还有很多高级的操作可以查看官网 nrm nrm是一个用来快速切换pm2的,让你在多个镜像源之间来回穿梭 nrm常用命令 npm i -g nrm 全局安装nrm nrm ls 查看有多少个镜像源 nrm add [home] 添加一个镜像源 nrm use 使用某个镜像源 nrm current 当前在哪个镜像源 nrm del 删除某个镜像源 还有很多高级的操作可以查看官网 nodemon nodemon可以让你每次修改完js代码之后,只要保存之后,他就会重新加载这个代码段 npm install -g nodemon 全局安装nodemon nodemon app.js 监控这个代码段 还有很多高级的操作可以查看官网","categories":[{"name":"Node","slug":"Node","permalink":"https://2662419405.github.io/categories/Node/"}],"tags":[{"name":"nvm","slug":"nvm","permalink":"https://2662419405.github.io/tags/nvm/"},{"name":"nrm","slug":"nrm","permalink":"https://2662419405.github.io/tags/nrm/"},{"name":"node","slug":"node","permalink":"https://2662419405.github.io/tags/node/"},{"name":"pm2","slug":"pm2","permalink":"https://2662419405.github.io/tags/pm2/"},{"name":"nodemon","slug":"nodemon","permalink":"https://2662419405.github.io/tags/nodemon/"},{"name":"工具大合集","slug":"工具大合集","permalink":"https://2662419405.github.io/tags/%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%90%88%E9%9B%86/"}]},{"title":"用pjax让你的页面加载飞起来!","slug":"pjax","date":"2019-12-20T12:25:48.000Z","updated":"2019-12-20T12:29:23.135Z","comments":true,"path":"2019/12/20/pjax/","link":"","permalink":"https://2662419405.github.io/2019/12/20/pjax/","excerpt":"什么是pjax? pjax = ajax + pushState 目的! 让页面加载飞起来","text":"什么是pjax? pjax = ajax + pushState 目的! 让页面加载飞起来 什么是pjax?pjax = ajax + pushState 通过ajax让页面进行局部刷新,然后通过pushstate让url发生改变,再让pushState,让页面产生一个回退的记录,从而让页面的性能进行大幅度的优化 简单demo感受一下 准备两个页面 index.html content.html index.html 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html class=\"font-auto\" lang=\"zh-cmn-hans\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;残梦博客园&lt;/title&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/pjax/pjax.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;loader&gt; &lt;div class=\"plane\"&gt;&lt;/div&gt; &lt;/loader&gt; &lt;header&gt; 页眉内容... &lt;/header&gt; &lt;main&gt; &lt;a href=\"content.html\"&gt;中间&lt;/a&gt; &lt;/main&gt; &lt;footer&gt; 页尾内容... &lt;/footer&gt;&lt;/body&gt;&lt;script&gt; var pjax = new Pjax(&#123; // 在页面进行 PJAX 时需要被替换的元素或容器，一条一个 CSS 选择器，数组形式 selectors: [ \"title\", \"meta[name=description]\", // 如果是全部 meta 替换的话，只需要写 meta \"main\" ], cacheBust: false &#125;)&lt;/script&gt;&lt;/html&gt; content.html 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html class=\"font-auto\" lang=\"zh-cmn-hans\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;残梦博客园&lt;/title&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/pjax/pjax.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;loader&gt; &lt;div class=\"plane\"&gt;&lt;/div&gt; &lt;/loader&gt; &lt;header&gt; 页眉内容... &lt;/header&gt; &lt;main&gt; &lt;a&gt;中间&lt;/a&gt; &lt;/main&gt; &lt;footer&gt; 页尾内容... &lt;/footer&gt;&lt;/body&gt;&lt;script&gt; var pjax = new Pjax(&#123; // 在页面进行 PJAX 时需要被替换的元素或容器，一条一个 CSS 选择器，数组形式 selectors: [ \"title\", \"main\" ], cacheBust: false &#125;)&lt;/script&gt;&lt;/html&gt; 发现真的是神速啊,用f12看了一下,发现就中间的dom结构发生了改变(这里面也就是main发生了改变),页面的js,css脚本也不用重新下载 深度学习一下感受到了他的牛逼之后,我们不如让我们的页面也能这样去渲染,岂不是很快 在github上面,我们可以找到pjax,主要分为两个版本 不需要jquery插件的pjax (这里面我们使用这种方式) 需要jquery的pjax 引入脚本引入pjax的CDN加速脚本 1&lt;script src=\"https://cdn.jsdelivr.net/npm/pjax/pjax.js\"&gt;&lt;/script&gt; 首先我们要实例化Pjax,并且传入一个对象第一个参数一般是指我们想让点击哪里去触发pjax(这里面只能指向a或者form)第二个参数为一个选择器数组,我们传递的是我们需要更新的dom节点(更新的dom越少,性能越好,当然尽量不要写重复的结构) 1234567891011var pjax = new Pjax(&#123; elements: \"a\", selectors: [ \"title\", \".l_main\", \".l_side .toc-wrapper\", \"#links\", \".comments\", \"#pages\", ]&#125;) 这样我们就成功的配置完了pjax但是新的页面可能需要渲染的dom结构很大,可能产生一瞬间的停顿,这样就会让页面像卡主了一样,没有给用户良好的反馈,我们可以自己做一个loading的加载或者使用nprogress,据说github就是使用的nprogress+pjax(发现自己之前真的是故落寡闻了) 优化加载准备css文件 12345678.loading&#123;display:none&#125;.loading&#123;height:100%;width:100%;position:fixed;top:0;left:0;z-index:999999;background-color:rgba(250,250,250,.9)&#125;.loading img&#123;width: 280px;height:210px;position: relative;top: 45%;left: 50%;margin-left:-140px;margin-top: -105px;&#125;#loader&#123;display: block; position: relative; left: 50%; top: 50%; width: 150px; height: 150px; margin: -75px 0 0 -75px; border-radius: 50%; border: 3px solid transparent; border-top-color: #ff5a5a; -webkit-animation: spin 1s linear infinite; animation: spin 1s linear infinite;&#125;#loader:before&#123;content: \"\"; position: absolute; top: 5px; left: 5px; right: 5px; bottom: 5px; border-radius: 50%; border: 3px solid transparent; border-top-color: #5af33f; -webkit-animation: spin 3s linear infinite; animation: spin 3s linear infinite;&#125;#loader:after&#123;content: \"\"; position: absolute; top: 15px; left: 15px; right: 15px; bottom: 15px; border-radius: 50%; border: 3px solid transparent; border-top-color: #6dc9ff; -webkit-animation: spin 2s linear infinite; animation: spin 2s linear infinite;&#125;@-webkit-keyframes spin&#123;0%&#123;-webkit-transform: rotate(0deg); -ms-transform: rotate(0deg); transform: rotate(0deg);&#125; 100%&#123;-webkit-transform: rotate(360deg); -ms-transform: rotate(360deg); transform: rotate(360deg);&#125;&#125;@keyframes spin&#123;0%&#123;-webkit-transform: rotate(0deg); -ms-transform: rotate(0deg); transform: rotate(0deg);&#125; 100%&#123;-webkit-transform: rotate(360deg); -ms-transform: rotate(360deg); transform: rotate(360deg);&#125;&#125; 准备一个html结构的div,选择器的名字和上面对应上就好,怎么写就看个人爱好了 1&lt;div class=\"loading\"&gt;&lt;div id=\"loader\"&gt;&lt;/div&gt;&lt;/div&gt; 准备一个js 123456789// 开始 PJAX 执行的函数document.addEventListener('pjax:send', function ()&#123; $(\".loading\").css(\"display\", \"block\");&#125;);// PJAX 完成之后执行的函数document.addEventListener('pjax:complete', function ()&#123; $(\".loading\").css(\"display\", \"none\");&#125;); 这样子我们的页面就可以进行快速跳转了,主需要渲染一部分哦! 效果可以在我的个人博客上面去看","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://2662419405.github.io/categories/Hexo/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://2662419405.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"pjax","slug":"pjax","permalink":"https://2662419405.github.io/tags/pjax/"},{"name":"ajax","slug":"ajax","permalink":"https://2662419405.github.io/tags/ajax/"},{"name":"html5","slug":"html5","permalink":"https://2662419405.github.io/tags/html5/"},{"name":"nprogress","slug":"nprogress","permalink":"https://2662419405.github.io/tags/nprogress/"},{"name":"github","slug":"github","permalink":"https://2662419405.github.io/tags/github/"},{"name":"loading","slug":"loading","permalink":"https://2662419405.github.io/tags/loading/"}]},{"title":"使用 Travis-CI 持续集成部署 HEXO 博客项目","slug":"kcxhjc","date":"2019-12-20T01:24:00.000Z","updated":"2019-12-20T07:40:33.225Z","comments":true,"path":"2019/12/20/kcxhjc/","link":"","permalink":"https://2662419405.github.io/2019/12/20/kcxhjc/","excerpt":"优点 让你的项目和源码能够完全分离,即使我们的项目被误删,也可以快速找回 当我们需要重复进行某些步骤的时候 直接在线编辑文件，立即生效 自动部署，同时部署到多个地方 发生错误,邮箱自动提醒","text":"优点 让你的项目和源码能够完全分离,即使我们的项目被误删,也可以快速找回 当我们需要重复进行某些步骤的时候 直接在线编辑文件，立即生效 自动部署，同时部署到多个地方 发生错误,邮箱自动提醒 What is Travis CI?Travis CI CI(Continuous Integration)翻译为持续集成。Travis CI是一个提供持续集成功能的平台，在Github上，可以添加Travis CI，当有code push时候，会推送通知到Travis，根据设置的脚本运行指定任务。 目前有两个站点: Travis.org 对于所有public项目完全免费 Travics.com 只针对private项目，提供更多一些额外功能，如cache，并行build个数 两个站点只能看到各自的项目，不能通用。 Why we need Travis CI?有人可能会有疑问: 在本地写完博客，直接一个命令hexo d，不就搞定了么， 为啥要费力搞CI？ 的确, 想用TravisCI来自动部署Hexo博客程序，需要不少设置（瞎折腾），为了给大伙信心，列举一些优点： 优点1：直接在线编辑文件，立即生效假设你已经发表了一篇文章，过了几天你在朋友机器上浏览发现有几个明显的错别字，对于有强迫症的，这是不能容忍的。 但你手头又没有完整的hexo+nodejs+git的开发环境，重新下载git，node，hexo配置会花费不少时间，特别不划算。 如果按照这篇完整折腾完，你可以直接用浏览器访问github个人项目仓库，直接编辑那篇post的原md文件，前后2分钟改完。 稍等片刻，你的博客就自动更新了。 优点2：自动部署，同时部署到多个地方在gitcafe是被收购之前，很多同学（包括我）都是托管在上面的，国内访问速度比Github快很多。配合DNS根据IP位置可以自动选择导到gitcafe, 还是github，甚至你还可以部署到七牛云的静态网站。利用Travis CI可同时更新多个仓库。 比如我的博客现在有两个站：一个部署在码云，一个部署在github。都需要我自己手动部署。 注：最后发现码云并不支持。emmmmm 优点3：部署快捷方便手动deploy需要推送public整个folder到github上，当后期网站文章、图片较多时候，对于天朝的网络，有时候连接github 就是不顺畅，经常要傻等不少上传时间。有了CI，你可以只提交post文件里单独的md文件即可，很快很爽，谁用谁知道。 优点4：bigger than bigger你的项目Readme里面可以显示CI build图标，很酷有没有？另外通过设置，可以在当build失败时自动发邮件提醒你。上面的图标，如果登陆后你在Github项目里，直接点击图标，会跳转到你当前项目build的log界面，很方便。 当然有了CI，你可以做很多事情，如自动运行单元测试，成功后再deploy等等。很多项目里的持续集成基本也是这个道理。 开始使用准备Travis CI账号 注册登录,travis-ci,就会自动显示我们的github下面的所有仓库,点击左上角 选择开启持续更新哪个仓库 准备github的Token 登录你的github账号,选择setting-&gt;Personal access tokens 注意,这里面生成token之后,在勾选的时候,除了删库,全都勾选上,注意生成之后的文件一定要保存起来,token之后就不可见了 在travis ci中添加我们的token 在hexo的根目录下面添加.travis.yml,并且开始编写 12345678910111213141516171819202122232425262728293031323334353637anguage: node_jsnode_js: stablecache: directories: - node_modulesbefore_install: - npm install -g hexo-cliinstall: - npm installscript: - hexo g after_script: - cd ./public - git init - git config user.name \"sh\" - git config user.email \"2662419405@qq.com\" - git add . - git commit -m \"TravisCI 自动部署\" # Github Pages - git push --force --quiet \"https://$&#123;githubblog&#125;@$&#123;GH_REF&#125;\" master:masterenv: global: - GH_REF: github.com/2662419405/2662419405.github.io.git notifications: email: - 2662419405@qq.com - qq2662419405@163.com on_success: change on_failure: always 上面的邮箱和用户名改成自己的,GH_REF改为自己的github地址,注意格式和我的相符,${githubblog}改为刚刚token的key 测试一下当你弄完这些之后,在hexo根目录 12345git initgit add .git commit -m &apos;测试Travis ci持续化集成&apos;git remote add origin xxx //这个地方是你的源码地址git push origin master 我们的测试就大功告成!!!!","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://2662419405.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://2662419405.github.io/tags/Hexo/"},{"name":"学习之旅","slug":"学习之旅","permalink":"https://2662419405.github.io/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"name":"BLOG","slug":"BLOG","permalink":"https://2662419405.github.io/tags/BLOG/"},{"name":"Github","slug":"Github","permalink":"https://2662419405.github.io/tags/Github/"},{"name":"Travis CI","slug":"Travis-CI","permalink":"https://2662419405.github.io/tags/Travis-CI/"},{"name":"持续集成自动部署","slug":"持续集成自动部署","permalink":"https://2662419405.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"name":"Token","slug":"Token","permalink":"https://2662419405.github.io/tags/Token/"}]},{"title":"性能优化大合集,必备!","slug":"xnyh","date":"2019-12-10T13:26:02.000Z","updated":"2019-12-10T14:38:00.945Z","comments":true,"path":"2019/12/10/xnyh/","link":"","permalink":"https://2662419405.github.io/2019/12/10/xnyh/","excerpt":"重定向 → 拉取缓存 →DNS 查询 → 建立 TCP 链接 → 发起请求 → 接收响应 → 处理 HTML 元素 → 元素加载完成 重要性: 一个网站的体验，决定了用户是否愿意去了解网站的功能；而网站的功能，决定了用户是否会一票否决网站的体验。这是改版自网络上的一句流行语，但却把网站性能这件事说的十分透彻，特别是在网站这样的项目中，如果一个用户需要超过5s才能看见页面，他会毫不犹豫地关闭它。","text":"重定向 → 拉取缓存 →DNS 查询 → 建立 TCP 链接 → 发起请求 → 接收响应 → 处理 HTML 元素 → 元素加载完成 重要性: 一个网站的体验，决定了用户是否愿意去了解网站的功能；而网站的功能，决定了用户是否会一票否决网站的体验。这是改版自网络上的一句流行语，但却把网站性能这件事说的十分透彻，特别是在网站这样的项目中，如果一个用户需要超过5s才能看见页面，他会毫不犹豫地关闭它。 1. 网络传输层加速 缓存一般分为强缓存和协商缓存，主要区别是：使用本地缓存的时候，是否需要向服务器验证本地缓存是否依旧有效。 浏览器缓存强缓存主要通过 http 请求头中的 Cache-Control 和 Expire 两个字段控制 一般，我们会设置 Cache-Control 的值为“public, max-age=xxx”，表示在 xxx 秒内再次访问该资源，均使用本地的缓存，不再向服务器发起请求。 协商缓存每次都向服务器验证一下缓存的有效性 前端缓存方案 HTML：使用协商缓存 CSS JS Image：使用强缓存，文件名带上 hash 值 浏览器默认的缓存是放在内存内的，但我们知道，内存里的缓存会因为进程的结束或者说浏览器的关闭而被清除，而存在硬盘里的缓存才能够被长期保留下去。很多时候，我们在 network 面板中各请求的 size 项里，会看到两种不同的状态：from memory cache 和 from disk cache，前者指缓存来自内存，后者指缓存来自硬盘。而控制缓存存放位置的，不是别人，就是我们在服务器上设置的 Etag 字段。在浏览器接收到服务器响应后，会检测响应头部（Header），如果有 Etag 字段，那么浏览器就会将本次缓存写入硬盘中。 资源打包压缩 网络性能优化措施归结为三大方面：减少请求数、减小请求资源体积、提升网络传输速率 1gulp grunt webpack parcel 图片资源优化 用过ngxin的人都知道,ngxin可以把文件设置为gzip压缩格式,但是图片不要设置gzip压缩!图片不要设置gzip压缩!图片不要设置gzip压缩! 不要在 HTML 里缩放图像 使用雪碧图（CSS Sprite）- webpack-spritesmith 使用字体图标（iconfont）- icomoon 使用 WebP - 图片压缩体积大约只有 JPEG 的 2/3，并能节省大量的服务器带宽资源和数据空间 网络传输性能检测工具Page Speed | PageSpeed Insights 使用 CDN再好的性能优化实例，也必须在CDN的支撑下才能到达极致。 如果我们在Linux下使用命令$ traceroute targetIp 或者在Windows下使用批处理 &gt; tracert targetIp，都可以定位用户与目标计算机之间经过的所有路由器，不言而喻，用户和服务器之间距离越远，经过的路由器越多，延迟也就越高。使用CDN的目的之一便是解决这一问题 2.页面渲染性能优化浏览器渲染过程 webkit 浏览器的解释器，是包括在渲染引擎内的，我们常说的 Chrome（现在使用的是 Blink 引擎）和 Safari 使用的 Webkit 引擎，Firefox 使用的 Gecko 引擎，指的就是渲染引擎。而在渲染引擎内，还包括着我们的 HTML 解释器（渲染时用于构造 DOM 树）、CSS 解释器（渲染时用于合成 CSS 规则）还有我们的 JS 解释器。不过后来，由于 JS 的使用越来越重要，工作越来越繁杂，所以 JS 解释器也渐渐独立出来，成为了单独的 JS 引擎，就像众所周知的 V8 引擎，我们经常接触的 Node.js 也是用的它。 重排和重绘 重排（reflow）：渲染层内的元素布局发生修改，都会导致页面重新排列，比如窗口的尺寸发生变化、删除或添加DOM元素，修改了影响元素盒子大小的CSS属性（诸如：width、height、padding）。 ②重绘（repaint）：绘制，即渲染上色，所有对元素的视觉表现属性的修改，都会引发重绘。 优化方式 CSS 属性读写分离 通过切换 class 或者 style.csstext 属性去批量操作元素样式 DOM 元素离线更新 将没用的元素设为不可见：visibility: hidden，减少重绘的压力 压缩 DOM 的深度：少用 DOM 完成页面样式，多使用伪元素或者 box-shadow 取代。 图片在渲染前指定大小：因为 img 元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在渲染前就指定其大小，或者让其脱离文档流。 对页面中可能发生大量重排重绘的元素单独触发渲染层，使用 GPU 分担 CPU 压力。（慎重） 3. JS阻塞 都知道js在加载的时候,会阻塞整个脚本的运行,我们可以把js脚本放到页面的尾部,这样页面会先加载出来,还可以通过让js脚本异步执行 js脚本异步执行的方式 给script标签添加defer 如果有多个设置了defer的script标签存在，则会按照顺序执行所有的script； 给script标签添加async 并不会按着script在页面中的顺序来执行，而是谁先加载完谁执行。 动态创建Script标签 4. 负载均衡 之所以将负载均衡作为拓展内容，是因为如果是你自己搭建的个人网站，或者中小型网站，其实并不需要考虑多大的并发量，但是如果你搭建的是大型网站，负载均衡便是开发过程不可或缺的步骤。 Nodejs处理IO密集的请求我们都知道node的核心是事件驱动，通过loop去异步处理用户请求，相比于传统的后端服务，它们都是将用户的每个请求分配到异步队列进行处理。事件驱动的最大优势是什么？就是在高并发IO时，不会造成堵塞，对于直播类网站，这点是至关重要的，我们有成功的先例——快手，快手强大的IO高并发究其本质一定能追溯到node。 一般现在的企业网站都会做一个中间层,比如淘宝的双十一,可以很大的减轻负担 pm2实现Node.js“多线程”那些说node不行的都是指着node是单线程这一个软肋开撕，告诉你，我们有解决方案了——pm2,就是能在你的计算机里的每一个内核都启动一个node.js服务，也就是说如果你的电脑或者服务器是多核处理器（现在也少见单核了吧），它就能启动多个node.js服务，并且它能够自动控制负载均衡，会自动将用户的请求分发至压力小的服务进程上处理。 nginx搭建反向代理所谓代理就是我们通常所说的中介，网站的反向代理就是指那台介于用户和我们真实服务器之间的服务器，它的作用便是能够将用户的请求分配到压力较小的服务器上，其机制是轮询。听完这句话是不是感觉很耳熟，没错，在我介绍pm2的时候也说过同样的话，反向代理起到的作用同pm2一样也是实现负载均衡，你现在应该也明白了两者之间的差异，反向代理是对服务器实现负载均衡，而pm2是对进程实现负载均衡","categories":[],"tags":[{"name":"Node","slug":"Node","permalink":"https://2662419405.github.io/tags/Node/"},{"name":"性能优化","slug":"性能优化","permalink":"https://2662419405.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"CDN","slug":"CDN","permalink":"https://2662419405.github.io/tags/CDN/"},{"name":"Pm2","slug":"Pm2","permalink":"https://2662419405.github.io/tags/Pm2/"},{"name":"雪碧图","slug":"雪碧图","permalink":"https://2662419405.github.io/tags/%E9%9B%AA%E7%A2%A7%E5%9B%BE/"},{"name":"Webp","slug":"Webp","permalink":"https://2662419405.github.io/tags/Webp/"},{"name":"反向代理","slug":"反向代理","permalink":"https://2662419405.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"},{"name":"ngxin","slug":"ngxin","permalink":"https://2662419405.github.io/tags/ngxin/"},{"name":"iconfont","slug":"iconfont","permalink":"https://2662419405.github.io/tags/iconfont/"}]},{"title":"git开发流程和常见命令","slug":"gitEasy","date":"2019-12-08T10:35:37.000Z","updated":"2020-01-15T12:45:57.124Z","comments":true,"path":"2019/12/08/gitEasy/","link":"","permalink":"https://2662419405.github.io/2019/12/08/gitEasy/","excerpt":"git,是一种版本控制工具,用于整合项目或者项目回滚有很好的效果,相比于svn,git操作更加灵活,限制更少一些","text":"git,是一种版本控制工具,用于整合项目或者项目回滚有很好的效果,相比于svn,git操作更加灵活,限制更少一些 git学习工作流程图 概念工作区(写代码的地方) git add 暂存区(临时的存储) git commit 本地库(历史版本) 初级操作 git status //状态查看 git add //添加到暂存区 git rm –cached //移除暂存区 git commit -m ‘xx’ //提交到本地库 版本操作 git log 命令可以显示所有提交过的版本信息 git reflog 可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作） git reset –hard xxx 索引值 git reset –hard HEAD^ 版本回退一次^^^退三步 git reset –hard HEAD~3 版本回退三步 reset命令的三个参数对比 –soft 仅仅在本地库移动一下指针 –mixed 在本地库移动HEAD指针,重置暂存区 –hard 在本地移动HEAD指针,重置暂存区,重置工作区 查找删除的文件 查找永久删除的文件 git reset –hard 版本回退 添加到暂存区的文件找回 git reset –hard HEAD 前提: 删除前,文件的改动保存在本地库了 操作: git reset –hrad[指针位置] 对比文件 diff 是工作区和暂存区比较 diff HEAD 是工作区和本地库比较 分支管理 命名一采用feature开头,代表功能 分支的具体操作 git branch -v 查看分支版本 git branch xxx 创建分支 git checkout name 选择分支 合并分支 切换到接受修改的分支上 执行 git merge 被合并的分支上 解决冲突 首先产生的原因是: 两个分支的内容发生了冲突 解决方式 编辑文件,删除特殊符号 把文件修改到满意的程度 git add [filename] git commit -m ‘提交信息’ git commit 不能写文件名字,必须和上面相符 基本原理分析哈希 不管输入量多大,他得到的加密结果长度是固定 输入唯一的一个明文,可以得到唯一的密文 输入的明文差异很小,变化很大 不可逆的 github使用 git remote -v 查看远程库 git remote add origin(别名) https://xxxxxxxx地址 创建连接 远程分支操作 git push origin master //推送分支,远程库别名,分支名 克隆仓库 下载到本地 创建origin远程地址别名 初始化本地库 多人开发 某个项目-&gt;setting-&gt;Collaborators-&gt;选择某个用户 用户就会接收到邀请,同意之后就可以加入到推送中 拉取仓库 pull = merge + fetch 拉取,等于下面两个命令 fetch 远程地址名 远程分支名 只是抓取下来,并没有合并 merge origin/master 合并文件 跨团队多人写作 git工作流程集中式工作流GitFlow(最常用) 通过分支去解决开发 hotfix 一般是解决bug develop 开发 feature_xxx 功能分支,基于develop开发 release 完成功能前的最终测试","categories":[],"tags":[{"name":"学习之旅","slug":"学习之旅","permalink":"https://2662419405.github.io/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"name":"git","slug":"git","permalink":"https://2662419405.github.io/tags/git/"},{"name":"多人开发","slug":"多人开发","permalink":"https://2662419405.github.io/tags/%E5%A4%9A%E4%BA%BA%E5%BC%80%E5%8F%91/"},{"name":"合作流程","slug":"合作流程","permalink":"https://2662419405.github.io/tags/%E5%90%88%E4%BD%9C%E6%B5%81%E7%A8%8B/"}]},{"title":"DIY自己的评论表情包","slug":"csbqb","date":"2019-12-03T12:55:45.000Z","updated":"2019-12-03T13:37:20.419Z","comments":true,"path":"2019/12/03/csbqb/","link":"","permalink":"https://2662419405.github.io/2019/12/03/csbqb/","excerpt":"定制属于自己的专属表情包,虽然Voline有自己的一套表情包,但是感觉不是很好看,那么现在就来自己定制一下吧","text":"定制属于自己的专属表情包,虽然Voline有自己的一套表情包,但是感觉不是很好看,那么现在就来自己定制一下吧 1. 下载js文件这个是建立在valine的基础上修改的文件,所以和valine使用方式一样,就是导入的js改变一下即可先clone一下仓库到本地,这个我就不说了 2. 本地测试在clone的目录下面,新建一个html文件导入js运行html测试一下js是否生效了 3. 加入自己想要的表情包 重新打开html页面,发现表情包添加了,但是变成了下面这样 微调css文件,加入下面的css文件调整,当然可以根据自己的个人爱好添加 1234567891011.l_main #comments .vemojis i .emoji &#123; height: 24px; margin-top: 6px; background: transparent;&#125;.l_main #comments .vemojis i &#123; width: auto; height: 36px; padding: 0; margin: 8px 8px 0 8px;&#125; 4. 修改Hexo这个表情包本身就是valine的表情包的扩展,所以直接修改hexo中导入的js文件即可把修改好的文件上传到自己的服务器上面,如果没有可以参考Github+jsDelivr上传到CDN我的是在themes\\material-x\\layout\\_partial\\script.ejs文件中,然后直接Ctrl+F搜索找到替换成自己的文件即可,我的js文件是https://cdn.jsdelivr.net/gh/2662419405/CDN/volantisPlus.js 最好把这个volantisPlus压缩一下,本人太懒了,就没弄,经过上面的配置,你也拥有了自己的DIY表情包,美滋滋啊","categories":[],"tags":[{"name":"表情包","slug":"表情包","permalink":"https://2662419405.github.io/tags/%E8%A1%A8%E6%83%85%E5%8C%85/"},{"name":"DIY","slug":"DIY","permalink":"https://2662419405.github.io/tags/DIY/"},{"name":"volantis","slug":"volantis","permalink":"https://2662419405.github.io/tags/volantis/"},{"name":"Hexo","slug":"Hexo","permalink":"https://2662419405.github.io/tags/Hexo/"}]},{"title":"加速自己的hexo，使用GitHub+Coding实现国内外网站加速","slug":"github-coding","date":"2019-11-30T05:19:28.000Z","updated":"2019-12-03T13:06:52.123Z","comments":true,"path":"2019/11/30/github-coding/","link":"","permalink":"https://2662419405.github.io/2019/11/30/github-coding/","excerpt":"基于Github+Coding实现国内外网站加速，让你的用户访问飞起来","text":"基于Github+Coding实现国内外网站加速，让你的用户访问飞起来 在配置好hexo之后，我们发现访问网站很慢，但又不是我们使用的主题的问题，那么就是网络环境的影响，即使我们使用了CDN加速，但还是没有我们国内的网站访问起来快速，（听说去美国的服务器要经过太平洋下面的区域,那访问起来也算是挺快了啊）,那我们就可以让我们的网站在国内和国外各备份一份,然后国内的用户访问国内的,国外的用户访问国外的网站 1. 创建项目进入 Coding 官网点击个人版登陆，没有账号就注册一个并登录，由于 Coding 已经被腾讯收购了，所以登录就会来到腾讯云开发者平台，点击创建项目 项目名称建议和你的用户名一致，这样做的好处是：到时候可以直接通过 user_name.coding.me 访问你的博客，如果项目名与用户名不一致，则需要通过 user_name.coding.me/project_name 才能访问，项目描述可以随便写 2. 配置公匙配置 SSH 公钥方法与 GitHub Pages 的方式差不多，点击你的头像，依次选择【个人设置】-【SSH公钥】-【新增公钥】 PS：公钥储存位置一般在 C:\\Users\\用户名.ssh 目录下的 id_rsa.pub 文件里，用记事本打开复制其内容即可 3.配置 _config.yml进入你的项目，在右下角有选择连接方式，选择 SSH 方式（HTTPS 方式也可以，但是这种方式有时候可能连接不上，SSH 连接不容易出问题），一键复制，然后打开你本地博客根目录的 _config.yml 文件，找到 deploy 关键字，添加 coding 地址：coding: git@git.dev.tencent.com:user_name/user_name.git，也就是刚刚复制的 SSH 地址 添加完成后先执行命令 hexo clean 清理一下缓存，然后执行命令 hexo g -d 将博客双线部署到 Coding Pages 和 GitHub Pages，如下图所示表示部署成功： 4.开启 Coding Pages进入你的项目，在代码栏下选择 Pages 服务，一键开启 Coding Pages，等待几秒后刷新网页即可看到已经开启的 Coding Pages， 5.绑定域名并开启 HPPTS首先在你的域名 DNS 设置中添加一条 CNAME 记录指向 Coding给的地址，解析路线选择默认，将 GitHub 的解析路线改为境外，这样境外访问就会走 GitHub，境内就会走 Coding，也有人说阿里云是智能解析，自动分配路线，如果解析路线都是默认，境外访问同样会智能选择走 GitHub，境内走 Coding，我没有验证过，有兴趣的可以自己试试，我的解析如下图所示： 然后点击静态 Pages 应用右上角的设置，进入设置页面，这里要注意，如果你之前已经部署到了 GitHub Pages 并开启了 HTTPS，那么直接在设置页面绑定你自己的域名，SSL/TLS 安全证书就会显示申请错误，如下图所示，没有申请到 SSL 证书，当你访问你的网站时，浏览器就会提示不是安全连接 申请错误原因是：在验证域名所有权时会定位到 Github Pages 的主机上导致 SSL 证书申请失败 正确的做法是：先去域名 DNS 把 GitHub 的解析暂停掉，然后再重新申请 SSL 证书，大约十秒左右就能申请成功，然后开启强制 HTTPS 访问 参考","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://2662419405.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://2662419405.github.io/tags/Hexo/"},{"name":"学习之旅","slug":"学习之旅","permalink":"https://2662419405.github.io/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"name":"BLOG","slug":"BLOG","permalink":"https://2662419405.github.io/tags/BLOG/"},{"name":"Github","slug":"Github","permalink":"https://2662419405.github.io/tags/Github/"},{"name":"Coding","slug":"Coding","permalink":"https://2662419405.github.io/tags/Coding/"}]},{"title":"史上最详细配置HTTPS","slug":"sszxxpz","date":"2019-11-27T13:21:44.000Z","updated":"2019-12-03T13:07:04.063Z","comments":true,"path":"2019/11/27/sszxxpz/","link":"","permalink":"https://2662419405.github.io/2019/11/27/sszxxpz/","excerpt":"给自己的博客(或者自己的服务器)配置一个免费的ssl证书,通过https访问 参考文档: https://support.huaweicloud.com/scm_faq/scm_01_0023.html 当然还是有很多的坑 让自己的服务器也加上锁吧!","text":"给自己的博客(或者自己的服务器)配置一个免费的ssl证书,通过https访问 参考文档: https://support.huaweicloud.com/scm_faq/scm_01_0023.html 当然还是有很多的坑 让自己的服务器也加上锁吧! HTTP（超文本传输协议），是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议，所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。 HTTPS（超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。 预览三种网站的效果 普通的http网站 https的网站 https+ssl证书的网站(也就是本网站) 获得SSL证书 我选择的华为云的ssl证书 证书一般是收费的,当然现在有很多网站推出了白嫖的ssl证书,虽然没有正常的ssl证书那样有很多安全,但是可以证明网站备案等 在华为云头部搜索”免费证书” 这里我们直接购买ssl证书,价格为0,购买之后,我们会收到一个qq邮箱提醒 我们点击下方的链接,用邮箱给我们的账号密码选择登录 如果是第一次访问,需要写一下东西,配置完之后如上图 我们下载之后,按照这个文档进行配置 如果你没有遇到问题,那么你很强,就不需要继续往下看了开始踩坑 第一个遇到的坑就是 ./Nginx -s reload 重启Nginx的时候,会出现一个ssl模板没有找到的错误 解决方式123456789101112# 进入到/usr/local/nginx-1.14.2（注：是nginx的源码包的目录），执行以下命令./configure --with-http_ssl_module # 注意这里只能用make 而不要用make install，因为执行make install是覆盖安装的意思make先备份旧的nginxcp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx_bak复制新生成的文件到安装路径：cp ./objs/nginx /usr/local/nginx/sbin/./nginx -s reload #进行重启 继续采坑中配置完之后发现,有了ssl证书,但是没有那个绿色的小锁头,很奇怪了 主要是由于页面使用了非https协议的文件,比如说&lt;img src=&quot;http:xxxx&quot; /&gt;,就会产生这个原因,那么我们把页面的http全部改写为https就发现我们的网站恢复了","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://2662419405.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://2662419405.github.io/tags/HTTPS/"},{"name":"SSL","slug":"SSL","permalink":"https://2662419405.github.io/tags/SSL/"},{"name":"网络安全","slug":"网络安全","permalink":"https://2662419405.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"CDN","slug":"CDN","permalink":"https://2662419405.github.io/tags/CDN/"},{"name":"服务器","slug":"服务器","permalink":"https://2662419405.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"域名","slug":"域名","permalink":"https://2662419405.github.io/tags/%E5%9F%9F%E5%90%8D/"}]},{"title":"ES6重点知识","slug":"es6study","date":"2019-11-26T05:53:00.000Z","updated":"2020-06-27T00:24:56.881Z","comments":true,"path":"2019/11/26/es6study/","link":"","permalink":"https://2662419405.github.io/2019/11/26/es6study/","excerpt":"ES6的常见语法","text":"ES6的常见语法 ES6(常用的、重点的)数组API、正则API、字符串API都不讲模板字符串 模板字符串的基本用法1var s1 = `abc` 模板字符串的优势：12var obj=&#123; name:\"\",age:5 &#125;;var s1 =\"我叫：\"+obj.name+\"，今年：\"+obj.age+\"岁。\" 解构赋值 对象的解构赋值 123456789var obj=&#123;name:\"张三\",age:18&#125;var &#123;name,age&#125;=obj; //生成2个变量，// name值来自于obj.name、// age值来自于obj.agevar &#123;name:title&#125;=obj;//生成一个变量：title，值来自于obj.name 函数参数的解构赋值 1234567891011function f1(obj)&#123; console.log(obj.age); console.log(obj.height)&#125;//等价于function f1(&#123; age,height &#125;)&#123; console.log(age); console.log(height)&#125;f1(&#123;age:5,height:180&#125;) 补充：属性的简写 123456var a = 3 ; var c = 10;var b = &#123; a,c &#125; ; //b对象有一个a属性，a属性的值，来自于a变量 ，//还有一个c属性，c属性的值来自于c变量console.log(b) 函数的扩展rest参数 使用背景：es6的 优点：arguments是伪数组，而rest参数是真数组 1234function fn(...args)&#123; console.log(args); //数组：[1,2,3,4,5]&#125;fn(1,2,3,4,5) 箭头函数 场景：用于替换匿名函数 基本用法： 12345678//匿名函数div.onclick=function()&#123; console.log(\"你好\")&#125;//箭头函数div.onclick=()=&gt;&#123; console.log(\"你好\")&#125; 有一个参数的箭头函数 1234567var fn=(a)=&gt;&#123; console.log(\"abc\");&#125;//等价于：var fn=a=&gt;&#123; console.log(\"abc\");&#125; 有2个及更多参数的箭头函数 123var f=(a,b,c)=&gt;&#123; console.log(\"abc\")&#125; 箭头函数和普通匿名函数有哪些不同？ 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 （不常用）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 generator函数现在经常用async替代 对象的扩展 Object.assign：实现拷贝继承 对象扩展运算符123var obj1=&#123; age:5,gender:\"男\" &#125;var obj2=&#123; ...obj1 &#125;var obj3=&#123; ...obj1 , age:10 &#125; Promise为什么要有promise：解决（回调地狱）的问题回调地狱：12345678910111213141516171819//跟以前的if条件地狱很像// if()&#123;// if()&#123;// if()&#123;// &#125;// &#125;// &#125;$.get(\"/getUser\",function(res)&#123; $.get(\"/getUserDetail\",function()&#123; $.get(\"/getCart\",function()&#123; $.get(\"/getBooks\",function()&#123; //... &#125;) &#125;) &#125;)&#125;)//node开发：读取文件；开个服务器、接收一个请求、请求路径、访问数据库 Promise函数基本用法1234567891011121314var promise=new Promise((resolve,reject)=&gt;&#123; //b 把需要执行的异步操作放在这里 $.get(\"/getUser\",res=&gt;&#123; //获取数据的异步操作已经执行完毕了，等待下一步的执行，通过执行resolve函数，告诉外界你可以执行下一步操作了 //c、 resolve(res) //而执行的下一步操作，其实就是写在then的回调函数中的 &#125;)&#125;)//a、promise.then(res=&gt;&#123; //d、执行后续的操作 console.log(res);&#125;) Promise函数实现多层回调123456789101112131415161718192021new Promise((resolve,reject)=&gt;&#123; $.get(\"/getUser\",res=&gt;&#123; resolve(res) &#125;)&#125;).then(res=&gt;&#123; //用户基本信息 return new Promise(resolve=&gt;&#123; $.get(\"/getUserDetail\",res=&gt;&#123; resolve(res) &#125;) &#125;)&#125;).then(res=&gt;&#123; //用户详情 return new Promise(resolve=&gt;&#123; $.get(\"/getCart\",res=&gt;&#123; resolve(res) &#125;) &#125;)&#125;).then(res=&gt;&#123; //购物车信息&#125;) Promise函数错误处理 第一种方式 12345678910111213141516new Promise((resolve,reject)=&gt;&#123; $.ajax(&#123; url:\"/getUser\", type:\"GET\", success:res=&gt;&#123; resolve(res); &#125;, error:res=&gt;&#123; reject(res) &#125; &#125;)&#125;).then(resSuccess=&gt;&#123; //成功的返回值&#125;,resError=&gt;&#123; //失败的返回值&#125;) 第二种方式 12345678910111213141516new Promise((resolve,reject)=&gt;&#123; $.ajax(&#123; url:\"/getUser\", type:\"GET\", success:res=&gt;&#123; resolve(res); &#125;, error:res=&gt;&#123; reject(res) &#125; &#125;)&#125;).then(resSuccess=&gt;&#123; //成功的返回值&#125;).catch(resError=&gt;&#123; //失败的返回值&#125;) async async其实是一个promise的语法糖 12345678910111213async function get()&#123; console.log('开始执行'); var res = await timer() console.log('执行结束：',res);&#125;function timer()&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(\"你好\"); &#125;,1000) &#125;)&#125;get(); await可以执行异步操作，但是await必须在async函数内执行 await操作可以有返回值，这个返回值表示promise操作成功的返回值 如果await里面执行的异步操作发生了reject，或者发生了错误，那么只能使用try…catch语法来进行错误处理 class定义一个类123456789class Person &#123; constructor(name) &#123; this.name=name; &#125;&#125;//相当于：function Person(name)&#123; this.name=name;&#125; 添加实例方法12345678910111213class Person &#123; constructor(name,age) &#123; this.name=name; this.age=age; &#125; //定义方法 say() &#123; console.log(\"大家好，我叫：\"+this.name+\"，今年：\"+this.age+\"岁\"); &#125; travel()&#123; console.log(\"坐着飞机去巴厘岛\"); &#125;&#125; 添加静态方法 静态成员：静态属性、静态方法 静态属性：通过类本身来访问：Person.maxAge 静态方法：通过类本身来访问的一个方法：Person.born();1234567891011class Animal &#123; constructor()&#123; &#125; //这就是一个静态方法了 static born()&#123; console.log(\"小呆萌出生了\") &#125;&#125;//访问静态方法Animal.born(); 类的继承1234567891011121314151617//父类class Person &#123; constructor(name)&#123; this.name=name; &#125;&#125;//Student类继承自Person类class Student extends Person &#123; //构造方法 constructor(name,grade)&#123; //规定：必须调用父类构造方法，如果不调用就会报错 super(name); //调用父类构造方法，从而给子类的实例添加了name属性 this.grade=grade; &#125;&#125; 123456789[1,3,5].map(function(value,index)&#123;&#125;)[1,3,5].map((value,index)=&gt;&#123;&#125;)//以前变量和字符串拼接，现在用模板字符串 es6的新语法 个人建议：不要去试想着一下子全部把之前的代码习惯变成es6的方式 而是今年学会了模板字符串，把今天项目用到的所有字符串拼接都换成模板字符串 过了几天学会了箭头函数，把当天项目里面的所有用到的匿名函数都换成箭头函数 预习作业：通过MDN学习Object.defineProperty()的用法module –&gt;放到后面的模块化课程中讲解基本用法 导出模块： 12//common.jsexport default &#123; name:\"abc\" &#125; 导入模块： 1234//b.jsimport common from \"common.js\"console.log( common.name ) //\"abc\" 模块有多个导出12345//person.jsexport const jim = &#123; country :\"France\" &#125;export const tony = &#123; color:\"gray\" &#125;//默认的导出export default &#123; name:\"abc\" &#125; 123456//index.jsimport person , &#123; jim , tony &#125; from \"person.js\"//person：&#123; name:\"abc\" &#125;//jim：&#123; country :\"France\" &#125;//tony：&#123; color:\"gray\" &#125; 模块导入导出取别名123456789//person.jsexport const tony = &#123; color:\"gray\" &#125;export &#123; tony as Tony &#125;//index.jsimport &#123; Tony &#125; from \"person.js\"import &#123; Tony as man&#125; from \"person.js\"console.log(man) //&#123; color:\"gray\" &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://2662419405.github.io/categories/JavaScript/"},{"name":"ES6","slug":"JavaScript/ES6","permalink":"https://2662419405.github.io/categories/JavaScript/ES6/"}],"tags":[{"name":"学习之旅","slug":"学习之旅","permalink":"https://2662419405.github.io/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"name":"箭头函数","slug":"箭头函数","permalink":"https://2662419405.github.io/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"},{"name":"ES6","slug":"ES6","permalink":"https://2662419405.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://2662419405.github.io/tags/JavaScript/"}]},{"title":"jQuery概念整理","slug":"jqstudy","date":"2019-11-26T05:28:39.000Z","updated":"2020-06-27T00:25:18.357Z","comments":true,"path":"2019/11/26/jqstudy/","link":"","permalink":"https://2662419405.github.io/2019/11/26/jqstudy/","excerpt":"","text":"一.jQuery的基本使用 1.0 2.0 3.0 分别支持ie8 部分支持ie8 全部不支持ie8 开发的时候最常用的是1.几版本 分为开发版本和压缩版本 带有min的是压缩版本，一般情况下使用的是开发版本 window.onload=function(){} &lt;=&gt; $(function(){}) 绑定文档加载完成的监听 分为两种使用 使用jQuery核心函数或者jQuery核心对象 核心函数$/jQuery 核心对象 执行$()返回的对象 二.jQuert的两把利器 jQuery的核心函数,直接可用 jQuery的核心对象,执行jQuery函数调用他 三.jQuery函数的使用 I.作为一般函数使用:$(param) 1). 参数为函数 : 当DOM加载完成后，执行此回调函数 2). 参数为DOM对象 : 将DOM对象封装成jQuery对象 3). 参数为选择器字符串 : 查找所有匹配的标签，并将他们分装成jQuery对象 4). 参数为html标签字符串 : (用的少)创建标签对象并分装成jQuery对象 II.作为对象使用:$.xxx() 1). $.each() : 隐使遍历数组 回调函数中第一个为key，第二个为value 2). $.trim() : 去除两端空格 III. 事件回调函数中 this指向的是 #btn DOM对象元素 四.jQuery对象的使用I. 理解 1).即执行jQuery核心函数返回的对象 2).jQuery对象内部包含的是dom元素对象的伪数组 3).jQuery对象拥有很多有用的方法和属性 II. 基本行为 1).size()/length : 包含的DOM元素 2).[index]/get(index) : 得到DOM元素对应的下标 3).each() : 遍历DOM元素 4).index() : 得到DOM元素的下标 III. 伪数组 1).伪数组是一个对象 2).伪数组必须有length属性 3).如果这个对象的length不为0，那么必须要有按照下标存储的数据 4).没有数组特别的方法 forEach() push() pop() splice()五.jQuery基本选择器1).class &quot;.b&quot;代表所有的class属性为b的元素 2).id &quot;#div&quot; 代表id元素 3).标签 &quot;div&quot; 代表标签元素 4).子集 &quot;div.box&quot; 代表class属性为btn中的div元素 5).并集 &quot;#b,#c&quot; 代表id为c和id为b的元素六.jQuery层次选择器I.查找子元素，后代元素，兄弟元素的选择器 1). &gt; 是指当前这一代的下一代，不包括下下代 2). + 是指当前元素的下一个元素，只包括一个 3). ~ 是指当前元素的后面所有兄弟姐妹元素(就是不能包括上一级的元素)七.jQuery过滤选择器I. 选择器 1). :first 正序 2). :last 倒叙 3). :not(.box) 选择不包含clss为box的元素 4). :lt(3):gt(0) 小于第三个大于第零个 5). :contains(&quot;name&quot;) 选择所有标签的innerHTML内容是name的标签 6). :hidden() 选择隐藏的标签 7). [title] 选择所有带有title属性的标签体 8). [title=hello] 选择title属性为hello的标签 II. 多个选择器不是同时执行，而是以此执行八.jQuery隔行换色1). odd:偶数 even:奇数 nth-child(2n)偶数九.jQuery表单选择器I.表单的常用选择器 1). text[disabled] :选择text文本的不可用输入框 2). checkbox:checked :选择被选中的复选框按钮 II. :等价于[] 在选择器中等价存在十.jQuery_$工具方法I.工具方法 1). $.each() : 遍历数组对象中的数据 2). $.trim() : 去除字符串两遍的空格 3). $.type(obj) : 得到数据类型 4). $.isArray(obj) : 判断是否是数组 5). $.isFunction(obj) : 判断是否是函数 6). $.parseJSON(json) : 解析json字符串转换为js对象 II. JSON 1). &apos;{&quot;name&quot;:&quot;Tom&quot; , &quot;Age&quot;:12 }&apos; 这是一个json 2). &apos;[{&quot;name&quot;:&quot;Tom&quot;,&quot;Age&quot;:12},{&quot;name&quot;:&quot;Allen&quot;,&quot;Age&quot;:24}]&apos; 这是一个json数组 3). JSON.parse(jsonString) json字符串----&gt;js对象/数组 4). JSON.stringify(jsObj/jsArr) js对象/数组----&gt;json字符串十一.jQuery多tab点击切换I. 设计思路 获取全部的DOM元素，然后通过this获取到这个index()，最后通过操作jQuery对象的下标的方式操作 II. 先获取全部的DOM元素，然后定义一个当前显示的元素的下标，先让这个元素隐藏，在显示当前点击的元素，最后更新下标（效率上更高）十二.jQuery属性I.属性 1).attr() 一个参数代表查看，两个参数代表第二个参数覆盖 但是不能操作布尔值 2).removeAttr() 移除 3).addClass() 添加class 4).html() 标签 有字符串代表-&gt;这是标签体 5).prop() 专门操作属性值为boolean的属性值十三.jQuery的CSS操作I.CSS操作 1).css() 一个参数代表查看，两个参数代表第二个参数覆盖 2).css({&apos;color&apos;:&apos;#ff0011&apos;})可以这是多个值十四.jQuery位置操作I.offset 和 position 1).offset().left 和 offset().top 两个可以获取相对于页面的位置 2).position() 和上面是一样，这个获取的是父元素的位置十五.jQuery中的位置滚动I.常用方法 1).scrollTop() 可以得到元素的滚动高度 2).scrollLeft() 可以得到x轴滚动距离 3).上面的两个方法(number) 既可设置滚动的距离 II.如何获取窗体滚动 获取页面的html+body两个滚动条的滚动总量十六.练习 jQuery回滚到顶部I.瞬间回到顶部 $(&apos;html,body&apos;).scrollTop(0) II.平滑滚动 计算总时间，时间间隔（定时器的时间）总距离 每次移动的距离（总距离除以需要的时间） 然后用定时器执行十七.jQuery元素的尺寸I.内容尺寸 1).height() :height 2).width() :width II.内部尺寸 1).innerHeight() :height+padding 2).innerWidth() :width+padding III.外部尺寸 1).outerHeight(false/true) :height+padding+border 如果是true，加上margin 1).outerWidth(false/true) :width+padding+border 如果是true，加上margin十八.jQuery的筛选I.过滤 1).first() 第一个 2).last() 最后一个 3).eq()* 指定某一个 参数为number 4).filter(&apos;[title=hello]&apos;) 指定title属性为hello的 5).not(&apos;[title=hello]&apos;) 指定不是hello的(还包括没有title属性) 6).filter(&apos;[title][title!=hello]&apos;) 交集选择器代表两个条件 7).has(&apos;span&apos;) 指向内部标签 II.查找 1).children() 子标签 2).find() 后代标签 3).parent() 父标签 4).prevAll() 前面的标签 5).siblings() 兄弟标签十九.jQuery文档操作 *I.增删改 1).append(ELement) 向内部最后添加元素 2).prepend(Element) 向内部最前添加元素 3).before(Element) 向兄弟前面添加元素 4).after(ELement) 向兄弟后面添加元素 5).replaceWith(Element) 替换指定的内部元素 6).remove(DOM_Element) 移除指定的内部元素二十.jQuery事件处理I.常用事件 1).mouseenter() 鼠标移入 2).mouseleave() 鼠标移出 II.事件处理 1).on(eve,fn) 第一个参数代表事件的处理方式 2).off() 和第一个相对应，取消时间绑定 3).点击时传入ev -&gt;ev.clientX 到客户端左上角的距离 -&gt;ev.pageX 到页面顶部左上角的距离 -&gt;ev.offsetX 到相对于事件左上角的距离 -&gt;ev.stopPropagation() 阻止事件的冒泡 -&gt;ev.preventDefault() 阻止事件的默认行为 III.事件切换 1).hover(fn,fn) 是mouseenter,mouseleave两个函数的回调函数 IV.区别mouseover与mouseenter *mouseover:在移入子元素时也会触发,对应mouseout *mouseenter:只在移入当前元素时触发,对应mouseleave V.事件委托 1).将多个子元素(li)的事件监听委托给父元素(ul)处理 2).监听回调是加在了父元素上 3).当操作任何一个子元素(li)时，事件会冒泡到父元素(ul)上 4).父辈元素不会直接处理，而是根据event.target得到发生事件的子元素(li)，通过这个子元素调用事件回调函数 5).委托方 ： 业主 li 6).被委托方 : 中介 ul 7).添加新的子元素，自动由事件响应处理 8).减少事件监听的数量: n==&gt;1 9).设置事件委托API: $(parentSelector).delegate(childrenSelector,eventName,callback) 10).取消事件的委托API:$(parentSelector).undelegate(eventName)二十一.jQuery动画I.内置动画 1).fadeOut() 淡入 param---&gt;number 代表存在秒数 2).fadeIn() 淡出 参数和上面一样 3).fadeToggle() 淡入淡出切换 可以传一个回调函数，当切换结束的时候触发 4).不断改变元素opacity来实现 5).slideDown() 带动画的展开 6).sildeUp() 带动画的收缩 7).sildeToggle() 带动画的切换展开/收缩 8).不断改变元素height实现 9).show() 显示 10).hide() 隐藏 11).toggle() 切换 12).不断改变opacity和height和width实现 II.自定义动画 1).animate() 指定自定义动画 参数可以传一个json 分别指定值 2).animate() 不需要带有单位，还可以进行字符串的加减 3).stop() 可以阻止动画的继续进行二十二.jQuery多库共存I.当多个$库同时存在时,需要使用 II.调用jQuery.noConflict()释放$使用权 III.下文需要调用的$时，只能使用jQuery二十三.区别onload与readyI.window.onload 1).包括页面的图片加载完后才会调用(晚) 2).只能有一个监听回调 II.$(document).ready() 1).等同于$(function(){}) 2).页面加载完就回调(早) 3).可以有多个监听回调二十四.jQuery扩展工具I.$扩展本身, 使用方式----&gt;$.min() 1).定义 $.extend({ xx:function(){ ... }, yy:function(){ ... } }) II.$添加新的方法,使用方式-----&gt;$.checkAll() 1).定义 $.fn.extend({ xx:function(){ ... }, yy:function(){ ... } })","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://2662419405.github.io/categories/jQuery/"},{"name":"前端","slug":"前端","permalink":"https://2662419405.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习之旅","slug":"学习之旅","permalink":"https://2662419405.github.io/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"name":"jQuery","slug":"jQuery","permalink":"https://2662419405.github.io/tags/jQuery/"},{"name":"前端","slug":"前端","permalink":"https://2662419405.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"npm简单使用","slug":"npmstudy","date":"2019-11-25T14:15:42.000Z","updated":"2019-11-28T04:49:31.378Z","comments":true,"path":"2019/11/25/npmstudy/","link":"","permalink":"https://2662419405.github.io/2019/11/25/npmstudy/","excerpt":"简单概括npm常用命令","text":"简单概括npm常用命令 npm包管理工具 npm可以理解为前端的maven,一个包的管理工具 1. 查看npm和node版本12node -v npm -v 2. 初始化项目npm init 默认配置初始化项目 npm init -y 3. 安装本地安装npm install &lt;Module Name&gt;@版本号 全局安装npm install &lt;Module Name&gt;@版本号 -g 指定版本 ^ 插入号 + 指定版本号：比如 ^3.5.2 ，安装3.x.x的最新版本（不低于 3.5.2），但是不安装 4.x.x提升版本,不提升大版本 指定版本号：比如 3.5.2 ，只安装指定版本 ~ 波浪号 + 指定版本号：比如 ~3.5.2 ，安装 3.5.x 的最新版本（不低于 3.5.2），但是不安装 3.6.x提升版本,不提升小版本 全局安装 如果你不知道npm的全局目录在哪,可以运行下面的命令 npm root -g 修改默认全局目录 npm config set prefix &quot;D:/npm&quot; 全局安装vue模板 npm install vue -g 查看全局安装的模板 npm list -g 生产环境模块开发 生产环境依赖安装 (默认) npm install &lt;Module Name&gt;[–save|S] 开发环境模块开发 开发模块依赖安装 npm install &lt;Module Name&gt;[--save-dev|D] 批量安装npm install or npm i 4. 模板本地模板 查看所有模板 npm list 查看全局所有模板 npm list -g 查看指定模板 npm list &lt;Module Name&gt; 远程模板 查看jquery的最新版本 npm view jquery version 查看jquery的全部版本 npm view jquery versions 卸载模块 布局卸载 npm install &lt;Module Name&gt; 全局卸载 npm install -g &lt;Module Name&gt; 5.修改淘宝镜像 查看当前镜像地址 npm get registory 配置淘宝镜像 npm config set registry https://registry.npm.taobao.org 安装下载模块 npm install &lt;Module Name&gt; 还原默认镜像地址 npm config set registry https://registry.npmjs.org/","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"https://2662419405.github.io/tags/npm/"},{"name":"包管理工具","slug":"包管理工具","permalink":"https://2662419405.github.io/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"}]},{"title":"博客园样式","slug":"bkyys","date":"2019-11-24T06:48:34.000Z","updated":"2019-12-13T01:13:24.746Z","comments":true,"path":"2019/11/24/bkyys/","link":"","permalink":"https://2662419405.github.io/2019/11/24/bkyys/","excerpt":"测试网址: https://www.cnblogs.com/sunhang32/ 实现目标: 学习更多的知识,了解更广的世界 简述原理: 自己整合并且简单修改 目前: 长期活跃的论坛之一,还在不断完善中","text":"测试网址: https://www.cnblogs.com/sunhang32/ 实现目标: 学习更多的知识,了解更广的世界 简述原理: 自己整合并且简单修改 目前: 长期活跃的论坛之一,还在不断完善中 欢迎来到残梦博客园首先声明一点: 样式并不全是本人所写,是我个人整合(感觉每个人的博客都喜欢一点,所以自己整合了一下) 由于每次更新博客,都需要重新更新此文档很麻烦,所以此博客只会定期更新,如果想要使用最新版本博客园样式,请前往本人github 如果喜欢的小伙伴可以自己配置首先你要有一个博客园(这个我估计我说的有点废话了)在博客园的官网左上角开通博客园博客园的个人配置页面-&gt;先申请js权限 禁用页面的css样式 选择页面的主题 粘贴一下代码到定制页面css代码中,由于css文件较大,所以这里提供了超链接css 粘贴博客侧面公告代码1234567891011121314151617181920212223242526&lt;script type=\"text/javascript\"&gt; window.cnblogsConfig = &#123; GhVersions : 'v1.2.0', // 版本 blogUser : \"残梦\", // 用户名 essayCodeHighlightingType: \"highlightjs\", essayCodeHighlighting: \"a11y-dark\", homeTopImg: [ \"https://cdn.jsdelivr.net/gh/2662419405/imgPlus/o_o_wallhaven-698904.jpg\" ], menuUserInfoBgImg: 'https://bndong.github.io/images/menu_bg.gif', menuNavList: [ // 列表数据 ['导航名称', '链接'] ['github', 'https://github.com/2662419405'], ['CSDN', 'https://blog.csdn.net/qq_43268396'], ['技能树', 'https://shtodream.cn/about/'], ['留言板', 'https://shtodream.cn/message/'], ], fontIconExtend: \"//at.alicdn.com/t/font_543384_ezv3l7gd9r7.css\", //字体图标扩展 webpageTitleOnblur : \"(◍´꒳`◍)你为何狠心离去 \", // 当前页失去焦点，页面title显示文字 webpageTitleOnblurTimeOut : 500, // 当前页失去焦点，页面title变化，延时时间，单位毫秒 webpageTitleFocus : \"(*´∇｀*) 帅的人回来了！\", // 当前页获取焦点，页面title显示文字，显示后延时恢复原title webpageTitleFocusTimeOut : 2000, // 当前页获取焦点，页面title变化，延时时间，单位毫秒 blogAvatar : \"https://cdn.jsdelivr.net/gh/2662419405/CDN@1.0/sh.jpg\", // 用户头像 blogStartDate : \"2019-11-07\", // 入园时间，年-月-日。入园时间查看方法,鼠标停留园龄时间上，会显示入园时间 &#125;&lt;/script&gt;&lt;script src=\"https://cdn.jsdelivr.net/gh/BNDong/Cnblogs-Theme-SimpleMemory@v1.2.0/src/script/simpleMemory.min.js\"&gt;&lt;/script&gt; 粘贴页首代码 1// 此处为空 粘贴页脚代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!-- 滚动进度 --&gt;&lt;div id=\"bottomProgressBar\"&gt;&lt;/div&gt;&lt;!-- 音乐菜单 --&gt;&lt;link rel=\"stylesheet\" href=\"https://blog-static.cnblogs.com/files/elkyo/APlayer.min.css\"&gt; &lt;div id=\"player\" class=\"aplayer aplayer-withlist aplayer-fixed\" data-id=\"3025663508\" data-server=\"netease\" data-type=\"playlist\" data-order=\"random\" data-fixed=\"true\" data-listfolded=\"true\" data-theme=\"#2D8CF0\"&gt;&lt;/div&gt; &lt;script src=\"https://blog-static.cnblogs.com/files/elkyo/APlayer.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://blog-static.cnblogs.com/files/elkyo/Meting.min.js\"&gt;&lt;/script&gt;&lt;!-- 网站运行时间 --&gt;&lt;p style=\"text-align:center;\"&gt;&lt;span id=\"timeDate\"&gt;载入天数...&lt;/span&gt;&lt;span id=\"times\"&gt;载入时分秒...&lt;/span&gt;&lt;/p&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date(\"11/06/2019 17:38:00\");//在此处修改你的建站时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = \"0\" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = \"0\" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = \"0\" + snum;&#125; document.getElementById(\"timeDate\").innerHTML = \"本站勉强运行 \"+dnum+\" 天 \"; document.getElementById(\"times\").innerHTML = hnum + \" 小时 \" + mnum + \" 分 \" + snum + \" 秒\"; &#125; setInterval(\"createtime()\",250);&lt;/script&gt;&lt;!-- 右下角菜单 --&gt;&lt;div id=\"rightMenu\"&gt;&lt;/div&gt; &lt;!--看板娘 - 猫--&gt; &lt;script src=\"https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js\"&gt;&lt;/script&gt;&lt;script&gt; L2Dwidget.init(&#123; \"model\": &#123; jsonPath: \"https://unpkg.com/live2d-widget-model-hijiki/assets/hijiki.model.json\",&lt;!--这里改模型，前面后面都要改--&gt; \"scale\": 1 &#125;, \"display\": &#123; \"position\": \"left\",&lt;!--设置看板娘的上下左右位置--&gt; \"width\": 100, \"height\": 200, \"hOffset\": 70, \"vOffset\": 0 &#125;, \"mobile\": &#123; \"show\": true, \"scale\": 0.4 &#125;, \"react\": &#123; \"opacityDefault\": 0.5,&lt;!--设置透明度--&gt; \"opacityOnHover\": 0.2 &#125; &#125;);window.onload=function()&#123; $(\"#live2dcanvas\").attr(\"style\",\"display:block;position: fixed; opacity: 0.7; left: 70px; bottom: 0px; z-index: 1; pointer-events: none;\")&#125;&lt;/script&gt;&lt;!-- 线条效果 --&gt;&lt;script type=\"text/javascript\"color=\"220,220,220\" opacity='0.9' zIndex=\"-2\" count=\"500\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"https://blog-static.cnblogs.com/files/sunhang32/myconsole.js\"&gt;&lt;/script&gt;&lt;!-- 文字显示 --&gt;&lt;script type=\"text/javascript\" src=\"https://files.cnblogs.com/files/sunhang32/myText.js\"&gt;&lt;/script&gt; ————–如果你对你的代码不满意的话,可以接下来自定义设置—————- 此处请前往github","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://2662419405.github.io/categories/jQuery/"}],"tags":[{"name":"博客园","slug":"博客园","permalink":"https://2662419405.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"},{"name":"样式自定义","slug":"样式自定义","permalink":"https://2662419405.github.io/tags/%E6%A0%B7%E5%BC%8F%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"name":"BLOG","slug":"BLOG","permalink":"https://2662419405.github.io/tags/BLOG/"},{"name":"jQuery","slug":"jQuery","permalink":"https://2662419405.github.io/tags/jQuery/"}]},{"title":"LAMP+JQ+AJAX开发","slug":"dycjcqd","date":"2019-11-20T00:16:04.000Z","updated":"2020-06-27T00:25:53.764Z","comments":true,"path":"2019/11/20/dycjcqd/","link":"","permalink":"https://2662419405.github.io/2019/11/20/dycjcqd/","excerpt":"测试网址: https://studyit.club 实现目标: 简易版社团,学习资源分享,富文本论坛,空间,美图秀秀等 简述原理: 常见前端框架混合使用 目前: 由于精力有限,目前暂停维护和开发","text":"测试网址: https://studyit.club 实现目标: 简易版社团,学习资源分享,富文本论坛,空间,美图秀秀等 简述原理: 常见前端框架混合使用 目前: 由于精力有限,目前暂停维护和开发 Study IT .club萌新报道1Hello Everybody ​ 第一次尝试分享一个自己写的非常简单的自己社团的官网 ​ 有兴趣的小伙伴可以去开一下 ——-&gt; 网站地址 效果图 语言和框架 数据库方面使用Mysql 数据库 没有事务处理 存储引擎为MyISAM 后台语言为PHP 讨论专区的框架为BootStrap 首页框架为 jQuery 谈论专区发帖的模块使用了 富文本编辑器UEditor 在个人空间主要AJAX滚动局部刷新 个人空间方面用了QQ表情包 个人设置用了美图秀秀的PC插件crossdomain.xml 个人空间使用 Highslide.js图片预览插件和多图片上传插件 安装和使用 需要挂载在本地的PHP服务器之上 推荐使用PHPstudy或者warm等集成开发环境 数据库方面配置在connect/config.php中,端口和数据库配置在这里面 所有的数据库模型都在主目录的 数据库.txt目录下面 美图秀秀插件配置:把主目录的 crossdomain.xml放在服务器的根目录 项目源码—-&gt;地址","categories":[{"name":"PHP","slug":"PHP","permalink":"https://2662419405.github.io/categories/PHP/"},{"name":"Mysql","slug":"Mysql","permalink":"https://2662419405.github.io/categories/Mysql/"}],"tags":[{"name":"我的项目","slug":"我的项目","permalink":"https://2662419405.github.io/tags/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/"},{"name":"学习之旅","slug":"学习之旅","permalink":"https://2662419405.github.io/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"}]},{"title":"React招聘聊天功能","slug":"dygReactxm","date":"2019-11-18T07:59:02.000Z","updated":"2020-06-27T00:26:38.370Z","comments":true,"path":"2019/11/18/dygReactxm/","link":"","permalink":"https://2662419405.github.io/2019/11/18/dygReactxm/","excerpt":"测试网址: https://github.com/2662419405/sh 实现目标: 双向聊天 简述原理: socketio全双工通信 目前bug: 注册之后再次登录才可以聊天","text":"测试网址: https://github.com/2662419405/sh 实现目标: 双向聊天 简述原理: socketio全双工通信 目前bug: 注册之后再次登录才可以聊天 简招 (React+Node+MongoDB) 开始制作的时间是从 2019-10-10 起至今 自己也发布过几个小型的demo,虽然没人看(๑•ૅૄ•๑), 但还是喜欢与大家共同学习进步 测试网址 ———&gt; 网址 介绍校园招聘APP,是一款手机端的求职网站,招聘者可以注册为BOSS,求职者可以注册为牛人,牛人和BOSS可以聊天,并且可以互相查看到对方的基本信息和简介薪资等方面 计划制作: 使用React的Antd-mobile支持手机端端制作 ReactNative独立开发App端和IOS 有人肯定会很好奇,PC和手机为何要制作两次,主要是本人很萌新,想要学习更多的框架 只有学习更多的框架,并且锻炼更好的自学能力,才能更上一层楼 关于我我是一个热门计算机并且对计算机充满兴趣的程序员 学过Java,.net,PHP,曾经一度认为PHP是最牛逼的语言 后来正式的接触前端,学习过 ES6 Node React Vue ReactNative Angular 微信一系列开发 jq,bootstarp等一些简单库 发现前端很神奇,比后台和数据方面更加的有意思,想要称为一名前端工程师 项目简述 这是一个React项目,你的电脑要具备Node(8.0)以上 所使用的node包技术阐述 前端主要采用了React全家桶，没什么多说的，脚手架构建项目，react-router控制路由，axios进行前后端交互。后端是基于node搭的服务，用的是express。我为什么不用koa呢，纯粹是图方便，因为koa不熟（捂脸）。聊天最重要的当然是通信，项目用socket.io来进行前后端通信。 =============分割线 下面是每个包的详细解释=============== (按需加载问题) 使用babel-plugin-import包 (由于跨域问题) 在package.json中使用proxy配置 需要详细说明一下,安装完这个包,需要在package.json文件中配置 \"proxy\": \"localhost:9093\" &lt;!--￼0--&gt; (配置服务端渲染) 使用babel-cli包 安装 npm install babel-cli --save &lt;!--￼1--&gt; 目录结构 123456789101112131415161718192021222324252627282930313233// 项目结构├─build├─config├─data│ ├─MongoDB // 数据库解释 ├─server // 后台│ ├─model // 数据库原型 │ ├─main // 后台文件入口 │ ├─user // 后台接口api ├─src│ ├─components // 全局组件│ │ ├─autoRouter│ │ ├─avatar-select│ │ ├─boss│ │ ├─chat│ │ ├─Dashboard│ │ ├─genius│ │ ├─img│ │ ├─logo│ │ ├─msg│ │ ├─navlink│ │ ├─shForm│ │ ├─user│ │ └─chatCard│ ├─router // 路由│ ├─index // 入口 │ ├─util // 方法│ ├─config // 请求拦截│ └─container│ ├─bossinfo // boss│ ├─login // 登录│ ├─register // 注册│ └─genuisinfo // 牛人 注册时, 进行密码MD5加密 12345// md5加密function md5pwd(pwd)&#123; const salt = 'qwe123~~-!@#$%^&amp;&amp;*()sunhang' return utility.md5(utility.md5(salt+pwd))&#125; 进行登录以及cookie的存储 123456789101112131415161718//进行注册Router.post('/register',(req,res)=&gt;&#123; const &#123; user,pwd,type &#125; = req.body User.findOne(&#123;user&#125;,(err,doc)=&gt;&#123; if(doc)&#123; return res.json(&#123;code:1,msg:'用户名存在'&#125;) &#125; const userModel = new User(&#123;user,type,pwd:md5pwd(pwd)&#125;) userModel.save(function(e,d)&#123; if(err)&#123; return res.json(&#123;code:2,msg:'后端出错了'&#125;) &#125; const &#123;user,type,_id&#125; = d res.cookie('userid',_id) return res.json(&#123;code:3,msg:'注册成功',data:&#123;user,type,_id&#125;&#125;) &#125;) &#125;)&#125;) axios拦截器的制作 1234567891011121314import axios from 'axios'import &#123; Toast &#125; from 'antd-mobile'//拦截请求axios.interceptors.request.use(function(config)&#123; Toast.loading('加载中',0); return config;&#125;)//拦截响应axios.interceptors.response.use(function(config)&#123; Toast.hide(); return config;&#125;) 登录和注册效果展示 双方聊天展示 消息的更新和排序 手机端表情包展示 手机端的表情包就是可以用的,现在的表情包都可以直接使用了,不同代码了,很神奇 后台方向 由于本人主要是面向前端,数据库就是MongoDB 数据库的使用请参照data目录下面的mongodb.md 数据库方面使用 (mongoose) 后台主要使用node的express 后台文件在server 使用方式 需要电脑有 mongo 和 react 还有node环境 首先:下载本项目 // 第一种方式 npm install //安装包依赖 npm run build //打包项目 npm run server //启动 打开浏览器输入localhost:9093 &lt;!--￼6--&gt; 如果还有bug和建议,欢迎告诉我 (͏ ˉ ꈊ ˉ)✧˖° 一开始还是遇到了很多的坑,第一次使用antd-mobile这个库,最主要的坑,还是对于项目的上线运行,毕竟个人不太擅长服务器的使用,在配置Nginx的时候卡了很久,为了性能优化,SSR渲染也是花了很大的心血,感觉里面的坑太多了,总的来说收获还是很大的,后期我还会画时间进行界面上的美化 感觉支持 喜欢的朋友记得给个star","categories":[{"name":"Node","slug":"Node","permalink":"https://2662419405.github.io/categories/Node/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://2662419405.github.io/categories/MongoDB/"},{"name":"React","slug":"React","permalink":"https://2662419405.github.io/categories/React/"}],"tags":[{"name":"我的项目","slug":"我的项目","permalink":"https://2662419405.github.io/tags/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/"},{"name":"学习之旅","slug":"学习之旅","permalink":"https://2662419405.github.io/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"name":"React","slug":"React","permalink":"https://2662419405.github.io/tags/React/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://2662419405.github.io/tags/MongoDB/"},{"name":"Node","slug":"Node","permalink":"https://2662419405.github.io/tags/Node/"}]},{"title":"前端常见面试题(一)","slug":"qdmst1","date":"2019-11-10T02:33:19.000Z","updated":"2019-12-10T02:36:09.800Z","comments":true,"path":"2019/11/10/qdmst1/","link":"","permalink":"https://2662419405.github.io/2019/11/10/qdmst1/","excerpt":"","text":"Web前段面试题1.doctype在严格模式下和混杂模式有什么区别?123451.&lt;!DOCTYPE&gt;声名位于文档的最前面，在&lt;HTML&gt; 标签的前面，告知浏览器以何种模式来渲染文档。2.严格模式的排版和JS运作模式都是以浏览器支持的最高的标准运行。按照W3C的标准来解析代码。3.混杂模式是以宽松的，向后兼容的方式来解析代码。是指浏览器用自己的方式解析代码，模拟老式浏览器的行为以防止网站停止工作。4.若DOCTYPE为声名或格式不正确，页面将会以怪异模式的方式解析。5.Doctype标签可声明三种DLD类型，分别是严格型，过渡型，框架型。 2.行内元素和块级元素和空元素?12345678内联元素（行内元素）内联元素(inline element)a、 abbr 、acronym、 b 、bdo、big 、br、code、dfn 、emfont、i、img、input、kbd 、label、q、s、samp、select、small、span、strike、strong 、sub、sup、textarea、 u、var块元素(block element)address、blockquote、center 、dir 、div 、dl 、 fieldset、form、h1 - h6 、hr 、menu 、noframes、、ol 、p、pre 、table 、ul空元素:br、meta、hr、link、input、img 3.页面导入时,使用link和@important的区别12import有兼容性问题,而css属于标签,会产生兼容性问题页面被加载的时候,link会同时被加载,而import会等到页面加载完在进行加载 4.常见的浏览器内核有哪些? 怎么样理解1234Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）] 5.H5新增的特性,移出了,移出了哪些属性12345678910111213141516171819202122232425262728增加: canvas 画布localStorage 本地离线缓存window.addEventListener 事件监听audio video 媒体标签sessionStorage 浏览器关闭自动删除sessionStoragefooter,nav 语义化标签Geolocation 地理定位websocket 通信date,time,url 表单组件webworker 专用线程移出的元素(纯表现形元素)&lt;basefont&gt; 默认字体，不设置字体，以此渲染&lt;font&gt; 字体标签&lt;center&gt; 水平居中&lt;u&gt; 下划线&lt;big&gt; 大字体&lt;strike&gt; 中横线&lt;tt&gt; 文本等宽(框架集)&lt;frameset&gt;&lt;frame&gt;&lt;noframes&gt;把 HTML5 的元素按优先级定义为结构性属性、级块性元素、行内语义性元素和交互性元素 4 大类。 6. 如何处理H5语义化标签的兼容性处理？123456利于SEO搜索引擎方便开发者理解模块IE8一下有兼容性问题使用document.createElement()创建元素 并且设置为块级元素 7. 浏览器怎么对H5的离线存储和资源的管理和加载？ 123在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。离线的情况下，浏览器就直接使用离线存储的资源。 8. H5的离线存储原理和使用？1234567891011121314151617181.在当前页面定义manifest例如&lt;!DOCTYPE HTML&gt;&lt;html manifest=&quot;cache.manifest&quot; &gt;&lt;/html&gt;2.写一个cache.manifest文件CACHE MANIFEST#v0.11CACHE: 这里写的文件会自动的缓存起来js/app.jscss/style.cssNETWORK: 这里的文件不会被缓存,但是如果CACHE里面有的话,就会被缓存,代表CACHE的优先级会更高./img/logo.pngFALLBACL: 如果第一个文件失败,则访问第二个文件/ /fail.html 如果访问根目录失败,则访问fail.html文件 9. cookie和localstorage,sessionstorage有什么区别？1234567891011121314151617181920212223相同点都存储在客户端。不同点1.存储大小cookie数据大小不能超过4k。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。2.有效时间localStorage：存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。sessionStorage：数据在当前浏览器窗口关闭后自动删除。cookie：设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。3. 数据与服务器之间的交互方式cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 10. iframe的缺点12345产生很多个页面,不容易管理不利于SEO搜索引擎设备兼容性差产生滚动条,用于体验差现在都是用AJAX来替代了frame框架 11. 如何实现的浏览器内多个标签页之间的通信？1234方法一:localstorage被修改添加等都会触发一个storage事件,通过监听这个事件可以实现通信方法二:cookie+setintveral 将数据存储在cookie当中,每隔一段事件读取一次cookie 12. css盒子模型123padding+margin+content+border独占一行,有宽高w3c和低版本IE有区别 13. css的选择符有哪些？哪些属性可以继承？123456789101112IDclass标签相邻+子&gt;后台li a通配符*属性a[ref=&quot;extral&quot;]伪类a:hover,li:nth-child可继承 font-size font-family color,不可继承 border padding margin width height ; 14. css优先级如何计算12345678important&gt;行内&gt;内嵌&gt;导入(链入)具体计算important无限大id 100class 10标签 1* 0注意: 最小的权重是继承的样式,比如父元素的权重为!important 但是继承的元素的权重还没有*高 15. css新增的伪类有哪些1234567p:nth-child(x)p:frist-of-typep:last-of-typep:only-typep:only-of-type:checked 被选中:enabled, :disabled 禁用状态 16. position absolute和relative的区别？1234区别一:relative会保留原先的位置,absolute不会区别二:absolute会相对于有定位的父元素进行定位,relative会相对于该元素的原先的位置进行定位 17. css弹性盒适用于哪些场景12多列盒子浮动时可以采用弹性盒适用于移动端操作 18. 经常遇见的浏览器问题有哪些,常用的hack的技巧有哪些12345678910图片下有一个块级元素 //会产生一个3px的缝隙给父元素设置浮动,子元素也设置浮动,低版本ie会双边距问题 //给父元素设置块级元素如果一个元素没有内容,最低高度为19px //font-size:0超链接的文字展示 //a:link-&gt;a:visited-&gt;a:hover-&gt;a:activeie低版本,当li最后一个标记设置浮动的时候,每个li之间会产生3px的像素 //vertical-top:top;ie低版本,png的图片无法展示 //导入js脚本补丁ie条件注释法css属性前缀法样式前缀法 19. 为什么初始化css的样式12每个浏览器的默认样式不一样,存在差异提高编码的质量 20. 如何理解BFC123456789不能从定义的角度去解释,bfc又叫做块级格式化上下文功能1. 内部元素清楚浮动2. 相邻的兄弟之间划清界限,可以用float+div配合制作自适应布局产生 float不为noneposition:absoluteoverflow设置除了auto一般脱离了文档流,都会产生bfc 21. 解释下浮动和它的工作原理？清除浮动的技巧1234567浮动的元素脱离了文档流,不占据空间,浮动元素碰到包含它的边框或者浮动元素的边框停留解决方式:1. 父元素设置一个高度,强制撑起来,不推荐,内容增多的时候,父元素的高度也会改变,而且也没有彻底清除掉浮动2. 设置一个常用的div,他的class为clear,设置为块级元素,清楚浮动,隐藏显示等3. 通过after设置一个伪类 a::after&#123;content:&quot;&quot;,display:none,visibity:hidden,clear:both&#125;4. 给父元素设置overflow,原理是父元素变为bfc,那么他就会管住子元素,让子元素不对外面的元素造成影响 22. DOM对于节点的常见操作12345678910111213141516创建节点createElement()createTextNode()createDocumentFragment() 常用于性能优化,给节点做一个缓冲增加,删除,替换,插入,克隆parentNode.appendChild(newNode)parentNode.insertBefore(PrevNode,newNode)replaceChild()removeChild()cloneNode()查找document.getElementById()document.getElementsByTagName()document.getElementsByClassName()document.form.document.getElementsByName() 23. webSocket如何解决兼容性问题12345介绍一下websocketwebsocket是一种全双工通信,采用的是ws和wss协议,和http不同,他是一种有状态的协议,可以有服务端主动发起请求,而http不行,在发送的信息上面也有区别,websocket可以发送二进制文件,但是通常情况下我们会选择发送json数据,可以有效的解决ajax长轮询带来的问题解决兼容性1. 虽然websocket在使用上面比ajax更加的有效,但是ajax长轮询有更好的兼容性2. 使用flash 24.你如何对网站的文件和资源进行优化123456使用CDN加速图片使用一些高校的图床服务器采用gzip压缩css和js文件都压缩(去掉空格和换行)采用多个域名进行缓存文件尽量合并,减少发出的http请求数量 25.线程于进程的区别1每个程序都有一个进程,每个进程都有一个线程 26.JS兼容性问题FF与IE1234567891011121314151617181920212223242526272829//IE下（两种）document.formName.item(\"itemName\");document.formName.elements [\"elementName\"];//Firefox下document.formName.elements[\"elementName\"];//解决方法：document.formName.elements[\"elementName\"]window.event只能在IE下运行,而不能在Firefox下运行IE下,可以使用eval(\"idName\")或getElementById(\"idName\")来取得id为idName的HTML对象;Firefox下只能使用getElementById(\"idName\")来取得id为idName的HTML对象；事件对象的属性用IE下,even对象有x,y属性,但是没有pageX,pageY属性;Firefox下,even对象有pageX,pageY属性,但是没有x,y属性；IE提供了attachEvent和detachEvent两个接口；而Firefox提供 的是 addEventListener和removeEventListener两个接口；getElementsByClassName不能兼容IE9之前的浏览器IE中支持使用parentElement和parentNode获取父节点。而 Firefox只可以使用parentNode。 27.常见的css兼容问题(主要针对于IE6,7)12345678910111213141516171. png的图片不加载解决: 换一种图片格式或者在晚上找插件去解决2. ie6的margin不能设置为负数解决: 可以通过相对定位设置3. 在ie6下,固定定位是无效的解决: 通过js去控制4. ie6,7中,输入类型的表单控件会有1px的间隙解决: 通过定位去设置5. ie6下面,绝对定位的父元素宽高设置为奇数的时候,会出现偏差解决: 在页面设计的时候,尽量去使用偶像素6.在ie6情况下,如果高度小于19px,会被当成19像素去处理解决: 添加overflow:hidden 28.字体为何设置为偶数1231. 考虑UI设计师的角度,一般设计师设计的时候使用的像素都是偶数2. 考虑兼容性问题,在ie6等低版本情况下的时候,如果像素设置为奇数,可能会造成汉子扁宽的效果3. 有时候会通过字体大小去设置页面的margin像素等问题,如果像素为14那么margin可以是14*1.5=21 如果是奇数的话,乘机就会出现小数问题 29.什么是AJAX,如何解决AJAX兼容性问题123456定义: AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。解决1. 通过jsonp的回调函数callback解决2. 通过CORS跨域资源共享,设置响应头3. 通过ngxin做一个代理 30.call和apply的区别和作用12345作用: 修改js里面的this指向问题区别: call接收多个参数,第一个参数为this指向的对象,后面的参数为传递的参数,apply接收两个参数,第一个参数为this指向的对象,第二个参数是一个数组,数组的内容是传递的参数总结：call和apply接收的参数不一样,但是实现的功能是一样的","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://2662419405.github.io/categories/JavaScript/"}],"tags":[{"name":"学习之旅","slug":"学习之旅","permalink":"https://2662419405.github.io/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"name":"前端","slug":"前端","permalink":"https://2662419405.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试题","slug":"面试题","permalink":"https://2662419405.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"兼容性","slug":"兼容性","permalink":"https://2662419405.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"bug","slug":"bug","permalink":"https://2662419405.github.io/tags/bug/"}]},{"title":"❤Thanksgiving❤","slug":"welcome","date":"2019-11-05T13:05:34.000Z","updated":"2019-12-03T13:08:17.492Z","comments":true,"path":"2019/11/05/welcome/","link":"","permalink":"https://2662419405.github.io/2019/11/05/welcome/","excerpt":"","text":"","categories":[],"tags":[{"name":"感谢相遇","slug":"感谢相遇","permalink":"https://2662419405.github.io/tags/%E6%84%9F%E8%B0%A2%E7%9B%B8%E9%81%87/"},{"name":"码农","slug":"码农","permalink":"https://2662419405.github.io/tags/%E7%A0%81%E5%86%9C/"},{"name":"苦逼程序员","slug":"苦逼程序员","permalink":"https://2662419405.github.io/tags/%E8%8B%A6%E9%80%BC%E7%A8%8B%E5%BA%8F%E5%91%98/"}]}]}